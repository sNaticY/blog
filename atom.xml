<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大喵的新窝</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://snatix.com/"/>
  <updated>2020-01-16T01:51:21.820Z</updated>
  <id>https://snatix.com/</id>
  
  <author>
    <name>sNatic</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Catlike学习笔记(2.4)-Unity多场景支持</title>
    <link href="https://snatix.com/2018/09/02/028-multiple-scenes/"/>
    <id>https://snatix.com/2018/09/02/028-multiple-scenes/</id>
    <published>2018-09-02T19:52:48.000Z</published>
    <updated>2020-01-16T01:51:21.820Z</updated>
    
    <content type="html"><![CDATA[<p>Hallo(德语) 大家好我又回来了没错上个礼拜又拖更了～原因是熬夜看 TI8 然而 LGD 居然输了，明明可以拿冠军的，枉费我小绿本充到 170 级，中国队偶数年魔咒已破所以就难过的没有更新文章。。嗯我想这个理由应该非常充分了吧～然后沉迷的『<a href="https://store.steampowered.com/app/281990/Stellaris/" target="_blank" rel="noopener">群星</a>』刚打完一把铁人模式准将难度唯心和平亲外流，种田种了 140 年除了中期危机没跟任何人发生战争，整个银河系因我而充满了和平与爱简直屌爆了～周六又突发奇想去玩了 <a href="https://store.steampowered.com/app/447530/VA11_HallA_Cyberpunk_Bartender_Action/" target="_blank" rel="noopener">VA-11 Hall-A</a> ，初体验来说我还挺喜欢这个令人放松的游戏的。。。</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>首先贴上『<a href="https://catlikecoding.com/unity/tutorials/object-management/multiple-scenes/" target="_blank" rel="noopener">原文链接</a>』嗯貌似引言部分硬生生被我写成了游戏推荐环节～所以概述就稍微多讲一些正事。。在『<a href="https://cn.snatix.com/2018/08/19/027-reusing-objects/" target="_blank" rel="noopener">上一篇</a>』中我们完成了对象池，那么在本篇中，我们会为对象池相关的对象在运行时创建一个新的场景，然后添加两个新的场景作为两个关卡，两个关卡有着不同的灯光并且支持一键切换，最后我们需要将关卡信息也保存到存档文件中～除了我们之前已经学习过的内容以外我们会遇到以下新的知识点：</p><ul><li>在 play mode 中创建场景</li><li>在不同场景之间移动 GameObject</li><li>多场景加载，卸载，制作，切换</li><li>创建关卡</li></ul><h2 id="PART-2-对象池专用场景"><a href="#PART-2-对象池专用场景" class="headerlink" title="PART 2 对象池专用场景"></a>PART 2 对象池专用场景</h2><p>首先我们注意到在主场景中加载一大堆 GameObject 以后我们的 Hierarchy 会变得异常混乱，从而很难找到某个特定 GameObject，还会拖慢 Editor 的运行效率就很烦～一个最最直观的解决方案就是把他们统一放到一个父级 GameObject 中，但这样也不是很好因为会多多少少影响我们游戏的运行效率，因此最好可以避免没有意义的嵌套。</p><p>那么更好的方法就是把所有的对象池加载出来的相关物体放置到另一个场景中，这样的话不需要嵌套也可以在编辑器里折叠起来，而且也不会降低运行效率。那么该怎么做呢？</p><h3 id="运行时创建场景并放入对象"><a href="#运行时创建场景并放入对象" class="headerlink" title="运行时创建场景并放入对象"></a>运行时创建场景并放入对象</h3><p>因为对象池是运行时创建的，因此我们同样需要在运行时创建一个新场景来放置对象池生成的物体，那么我们在<code>ShapeFactory</code>中添加如下代码：</p><pre><code class="lang-csharp">[CreateAssetMenu]public class ShapeFactory : ScriptableObject{    ...    private Scene _poolScene;    public Shape Get(int shapeId, int materialId)    {        Shape instance;        if (_recycle)        {            ...            if (lastIndex &gt;= 0)            {                ...            }            else            {                ...                SceneManager.MoveGameObjectToScene(instance.gameObject, _poolScene);            }        }        ...    }    private void CreatePools()    {        ...        _poolScene = SceneManager.CreateScene(name);    }}</code></pre><p>以上代码想必大家都很清楚，大概就是在创建对象池最后顺便也创建一个新场景，然后在创建新对象的时候放入该场景</p><h3 id="重编译后恢复"><a href="#重编译后恢复" class="headerlink" title="重编译后恢复"></a>重编译后恢复</h3><p>虽然博主觉得这个功能好像没什么用不过还是先照做比较好～简单来说就是目前的功能可以正常运行了，但是在运行状态下修改代码重新编译的话就会造成一些问题，因为 Unity 会在编译的时候序列化所有的<code>MonoBehaviour</code>，然而<code>ScriptableObject</code>却不会被序列化，也就是说我们的对象池<code>List</code>在重新编译后就会丢失引用，会导致<code>CreatePool()</code>再次被执行，从而导致一系列问题。于是我们需要修改如下代码：</p><pre><code class="lang-csharp">[CreateAssetMenu]public class ShapeFactory : ScriptableObject{    ...    private void CreatePools()    {        _pools = new List&lt;Shape&gt;[_prefabs.Length];        for (int i = 0; i &lt; _pools.Length; i++)        {            _pools[i] = new List&lt;Shape&gt;();        }        if (Application.isEditor)        {            _poolScene = SceneManager.GetSceneByName(name);            if (_poolScene.isLoaded)            {                GameObject[] rootObjects = _poolScene.GetRootGameObjects();                for (int i = 0; i &lt; rootObjects.Length; i++)                {                    Shape pooledShape = rootObjects[i].GetComponent&lt;Shape&gt;();                    if (!pooledShape.gameObject.activeSelf)                    {                        _pools[pooledShape.ShapeId].Add(pooledShape);                    }                }                return;            }        }        _poolScene = SceneManager.CreateScene(name);    }}</code></pre><p>需要注意的这种情况仅会在 Editor 中发生，因此我们需要用<code>Application.isEditor</code>来判断是否是 Editor 环境。然后获取场景并判断其是否已被加载，如果是的话就将其跟节点的所有 GameObject 加入<code>_pools</code>中这样～然后我们在运行时即使修改代码也可以直接重新编译继续运行而不会报错了！（说实话博主以前写代码从来没考虑过这个）</p><h2 id="PART-3-LEVEL-1"><a href="#PART-3-LEVEL-1" class="headerlink" title="PART 3 LEVEL 1"></a>PART 3 LEVEL 1</h2><p>通常来说场景并不只是用来做上面这样的用来容纳 GameObject 这样的事情，更常见的做法是每一关一个场景。不过在游戏中我们经常会遇到某些不属于任何场景的对象，在这种情况下我们可以选择将此类对象放置在一个单独的场景。</p><h3 id="多场景编辑"><a href="#多场景编辑" class="headerlink" title="多场景编辑"></a>多场景编辑</h3><p>首先我们创建一个新的场景<code>Level 1</code>，创建好以后只需要把场景拖到 Hierarchy 中就可以同时编辑多个场景，如图所示。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018090201.png" alt=""></p><p>然后我们需要删除 Level 1 中的 Main Camera 和主场景中的 Directional Light。运行一下会发现场景里的物体莫名其妙的变黑了～这主要是因为每个场景都有自己的 lighting settings，最终结果取决于我们使用哪个场景的 lighting settings。如图所示：</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018090202.png" alt=""></p><p>解决方案是右键点击 Level 1 再选择 Set Active Scene。再运行就发现恢复正常了～如图所示</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018090203.png" alt=""></p><h3 id="加载场景"><a href="#加载场景" class="headerlink" title="加载场景"></a>加载场景</h3><p>然而打包后，只有 index 0 会被自动加载，因此我们需要手动加载场景。添加如下代码：</p><pre><code class="lang-csharp">public class MultiSceneDemo: PersistableObject{    ...    private void Awake()    {        _objectList = new List&lt;Shape&gt;();        StartCoroutine(LoadLevel());    }       ...    private IEnumerator LoadLevel()     {        SceneManager.LoadScene(&quot;Level 1&quot;, LoadSceneMode.Additive);        yield return null;        SceneManager.SetActiveScene(SceneManager.GetSceneByName(&quot;Level 1&quot;));    }}</code></pre><p>需要注意的是<code>LoadLevel()</code>中的<code>yield return null</code>，主要原因是在加载场景后需要等待一帧才能完全加载好。但是运行一下会发现，即使我们已经调用<code>SetActiveScene()</code>但是环境光还是有问题，尽管打包以后是没有问题的，但是在 Editor 中运行时加载场景时，自动生成 lighting data 会出问题～那么该如何解决呢？</p><h3 id="Lighting-烘培"><a href="#Lighting-烘培" class="headerlink" title="Lighting 烘培"></a>Lighting 烘培</h3><p>为了确保光照数据被正常生成，我们需要取消 Auto Generate 选项，首先打开 Window / Lighting / Settings</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018090204.png" alt=""></p><p>然后打开 Level 1 场景，点击 Generate Lighting 后 Unity 会烘培光照数据并且保存在场景所在的文件夹中。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018090205.png" alt=""></p><p>此时再运行会发现一切正常～</p><h3 id="异步加载场景"><a href="#异步加载场景" class="headerlink" title="异步加载场景"></a>异步加载场景</h3><p>加载场景所需时间取决于场景本身的大小，在我们现在的场景就只有一个平行光因此就加载很快～但是一般来说时间都会稍长一些，会导致这段时间游戏卡顿。为了解决这个问题我们需要异步加载场景的技术～代码如下：</p><pre><code class="lang-csharp">public class MultiSceneDemo: PersistableObject{    ...    private IEnumerator LoadLevel()    {        enabled = false;        yield return SceneManager.LoadSceneAsync(&quot;Level 1&quot;, LoadSceneMode.Additive);        SceneManager.SetActiveScene(SceneManager.GetSceneByName(&quot;Level 1&quot;));        enabled = true;    }}</code></pre><p>只需要替换<code>LoadLevel()</code>中加载场景的代码为<code>SceneManager.LoadSceneAsync()</code>即可，同时为了防止在加载过程中玩家发送各种指令导致各种问题，我们需要把<code>component</code>临时关闭。</p><h3 id="防止多次加载"><a href="#防止多次加载" class="headerlink" title="防止多次加载"></a>防止多次加载</h3><p>虽然目前为止看起来好像是正常工作了，但是如果我们在游戏开始之前就加载两个场景就会出现奇怪的问题，就是场景被打开两次导致光线太明亮～虽然这种情况只有 Editor 模式中会发生但是我们还是要处理一下～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018090206.png" alt=""></p><p>修改代码如下：</p><pre><code class="lang-csharp">public class MultiSceneDemo : PersistableObject{    ...    // private void Awake()    private void Start()    {        _objectList = new List&lt;Shape&gt;();        if (Application.isEditor) {            Scene loadedLevel = SceneManager.GetSceneByName(&quot;Level 1&quot;);            if (loadedLevel.isLoaded) {                SceneManager.SetActiveScene(loadedLevel);                return;            }        }        StartCoroutine(LoadLevel());    }    ...}</code></pre><p>注意我们将原来的<code>Awake()</code>中的内容移动到<code>Start()</code>中，主要原因是在<code>Awake()</code>时场景并不会被标记为加载完成，因此在<code>Awake()</code>中判断是不行的，所以我们稍微延迟一点点放到<code>Start()</code>中就可以解决这个问题了～</p><h2 id="PART-4-更多关卡"><a href="#PART-4-更多关卡" class="headerlink" title="PART 4 更多关卡"></a>PART 4 更多关卡</h2><p>某些游戏只有一个关卡，不过大部分游戏都有多个关卡，所以我们现在尝试再创建一个关卡并且可以来回切换～首先我们把 Level 1 复制一下改名 Level 2 然后把平行光的角度 x 从 50 改成 1 最后在点击 Generate Lighting。</p><h3 id="检测已加载的关卡"><a href="#检测已加载的关卡" class="headerlink" title="检测已加载的关卡"></a>检测已加载的关卡</h3><p>虽然我们有可能需要同时打开多个关卡，不过一般来说同一时间只打开一个关卡的可能性更大一些～某些情况下我们可能需要同时打开多个场景进行修改之类或者复制粘贴之类的～但是一旦进入 Play Mode 我们还是希望除了主场景外只打开一个场景。如果我们在开始游戏之前就打开了 Level 2 的话就会又同时打开 Level 1。。所以为了防止这种情况发生，我们需要在<code>Start()</code>中检测关卡。代码如下：</p><pre><code class="lang-csharp">public class MultiSceneDemo : PersistableObject{    ...    private void Start()    {        _objectList = new List&lt;Shape&gt;();        if (Application.isEditor)        {            for (int i = 0; i &lt; SceneManager.sceneCount; i++) {                Scene loadedScene = SceneManager.GetSceneAt(i);                if (loadedScene.name.Contains(&quot;Level &quot;)) {                    SceneManager.SetActiveScene(loadedScene);                    return;                }            }        }        StartCoroutine(LoadLevel());    }}</code></pre><p>这样的话我们就可以在任意关卡打开的时候开始游戏了～（好像是很有用的功能）</p><h3 id="加载特定关卡"><a href="#加载特定关卡" class="headerlink" title="加载特定关卡"></a>加载特定关卡</h3><p>作为一个小游戏我们就简单的把数字键 1 和 2 作为切换场景的按键～稍微修改<code>LoadLevel()</code>即可实现，代码如下</p><pre><code class="lang-csharp">public class MultiSceneDemo : PersistableObject{    ...    public int LevelCount;    ...    private void Update()    {        ...        else        {            for (int i = 1; i &lt;= LevelCount; i++)            {                if (Input.GetKeyDown(KeyCode.Alpha0 + i))                {                    BeginNewGame();                    StartCoroutine(LoadLevel(i));                    return;                }            }        }        ...    }    ...    private IEnumerator LoadLevel(int levelBuildIndex)    {        enabled = false;        if (_loadedLevelBuildIndex &gt; 0)        {            yield return SceneManager.UnloadSceneAsync(_loadedLevelBuildIndex);        }        yield return SceneManager.LoadSceneAsync(levelBuildIndex, LoadSceneMode.Additive);        SceneManager.SetActiveScene(SceneManager.GetSceneByBuildIndex(levelBuildIndex));        _loadedLevelBuildIndex = levelBuildIndex;        enabled = true;    }}</code></pre><p>需要注意的是我们在加载每个场景后记录该场景的 Index，在下次加载场景时记得把之前加载的场景卸载掉～</p><h3 id="保存关卡"><a href="#保存关卡" class="headerlink" title="保存关卡"></a>保存关卡</h3><p>目前为止我们可以在游戏过程中切换场景了，但是无法保存关卡本身，因此我们就可以在某个关卡保存 GameObject 然后再另一个关卡加载，这样可能会出现问题，所以还是把关卡的 index 也写入存档中比较好～</p><p>为了支持之前版本的存档文件，我们再修改存档文件的版本号为 2，然后将当前场景的 index 写入存档～如果版本号低于 2 则默认加载场景 Level 1。代码如下</p><pre><code class="lang-csharp">public class MultiSceneDemo : PersistableObject{    ...    private int _saveVersion = 2;    ...    public override void Save(GameDataWriter writer)    {        writer.Write(_objectList.Count);        writer.Write(_loadedLevelBuildIndex);        ...    }    public override void Load(GameDataReader reader)    {        var version = reader.Version;        if (version &gt; _saveVersion)        {            Debug.LogError(&quot;Unsupported future save version &quot; + version);            return;        }        int count = version &lt;= 0 ? -version : reader.ReadInt();        StartCoroutine(LoadLevel(version &lt; 2 ? 1 : reader.ReadInt()));        ...    }    ...}</code></pre><p>最终效果如下～首先切换到场景 1，创建一些对象以后切换到场景 2，再按下<code>l</code>读取存档，可以自动切换回场景 1 并加载对象，测试通过～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018090302.gif" alt=""></p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>嗯本来以为这一篇结束以后『<a href="https://snatix.com/tags/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/">对象管理</a>』系列就告一段落了没想到作者又出了『<a href="https://catlikecoding.com/unity/tutorials/object-management/spawn-zones/" target="_blank" rel="noopener">新一篇</a>』～好吧那么只好下周再把对象管理系列完结了～嗯就这样决定了，我要继续在『<a href="https://store.steampowered.com/app/447530/VA11_HallA_Cyberpunk_Bartender_Action/" target="_blank" rel="noopener">VA-11 Hall-A</a>』中当一名善解人意的调酒师了大家拜拜～</p><hr><p>原文链接：<a href="https://snatix.com/2018/09/02/028-multiple-scenes/">https://snatix.com/2018/09/02/028-multiple-scenes/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      Unity多场景切换，Unity运行时创建场景，Unity中移动GameObject到其他场景，Unity同时编辑多个场景
    
    </summary>
    
      <category term="Catlike学习笔记" scheme="https://snatix.com/categories/Catlike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="教程" scheme="https://snatix.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="csharp" scheme="https://snatix.com/tags/csharp/"/>
    
      <category term="对象管理" scheme="https://snatix.com/tags/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Catlike学习笔记(2.3)-Unity对象池与重用</title>
    <link href="https://snatix.com/2018/08/19/027-reusing-objects/"/>
    <id>https://snatix.com/2018/08/19/027-reusing-objects/</id>
    <published>2018-08-19T16:34:48.000Z</published>
    <updated>2020-01-16T01:51:21.820Z</updated>
    
    <content type="html"><![CDATA[<p>短暂又美好的假期瞬间就过去了，已经上班 3 天了感觉每天早上都很困很想睡懒觉～而且也没有按照原计划在假期内完成「<a href="https://catlikecoding.com/unity/tutorials/object-management/" target="_blank" rel="noopener">对象管理</a>」的部分感觉好像有那么一点点惭愧（<del>其实完全不惭愧反正已经不知道拖延过多少次弃坑过更多次早就习惯了</del>)咳咳，然后最近几天沉迷『<a href="https://store.steampowered.com/app/281990/Stellaris/" target="_blank" rel="noopener">群星(Stellaris)</a>』（<del>睿智的P社玩家+1</del>） 话说为什么自从开始要求自己每个礼拜更新一篇博客以后比以前更容易沉迷游戏了。。。不管那些总之这一篇来到了 <a href="https://catlikecoding.com/unity/tutorials/object-management/reusing-objects/" target="_blank" rel="noopener">Reusing Object</a> ，主要讲了简单的对象池实现和使用，希望可以给大家带来一点点启发～</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>虽然主角是对象池但是如果没有一个好的可以跑起来的工程用来测试的话也不能发挥出对象池的威力～所以接『<a href="https://snatix.com/2018/08/08/026-object-variety/">上一篇</a>』和『<a href="https://snatix.com/2018/08/05/025-persisting-objects/">上上篇</a>』我们完成了一键创建随机材质颜色和形状的 GameObject 还可以实现保存和重新加载，最后还开启了 GPU Instancing，如果直接看这一篇有点莫名其妙的同学可以从第一篇过一遍～当然不关心场景是怎么创建出来的只想看看对象池的简单实现的话可以直接跳到「PART 4 对象池」。总之本篇的目标大概是以下这些：</p><ul><li>销毁对象</li><li>自动创建与销毁</li><li>创建简单的 UI 控制自动创建和销毁的速度</li><li>使用 Profiler 追踪内存分配</li><li>使用对象池回收</li></ul><h2 id="PART-2-添加一键删除随机对象"><a href="#PART-2-添加一键删除随机对象" class="headerlink" title="PART 2 添加一键删除随机对象"></a>PART 2 添加一键删除随机对象</h2><p>在之前的教程中我们完成了一键创建随机材质颜色和形状的 GameObject 并保存在<code>_objectList</code>中，那么相应的删除对象也很简单，大概就是从 List 中随机一个 index，销毁后再从 List 中删除即可，因此我们添加如下代码：</p><pre><code class="lang-csharp">public class ReusingDemo : PersistableObject{    ...    public KeyCode CreateKey = KeyCode.C;    public KeyCode DestroyKey = KeyCode.X;    ...    private void Update()    {        ...        else if (Input.GetKeyDown(DestroyKey))        {            DestroyObject();        }    }    ...    private void DestroyObject()    {        if (_objectList.Count &gt; 0)        {            int index = Random.Range(0, _objectList.Count);            Destroy(_objectList[index].gameObject);            _objectList.RemoveAt(index);        }    }    ...}</code></pre><p>简单的来说就是添加一个新的按键叫<code>DestroyKey</code>，在<code>Update()</code>中检测到该按键被按下时从<code>_objectList</code>中取出相应的 GameObject 并销毁，最后从<code>_objectList</code>中移除。不过这样有一个小小的不足之处，学过数据结构的同学都知道，在我们从 List / Array 之类的结构中移除一个对象的时候，会依次将后面的对象往前移动，这样就造成了不必要的性能开销～那么我们还可以稍微优化一下，代码如下：</p><pre><code class="lang-csharp">public class ReusingDemo : PersistableObject{    ...    private void DestroyObject()    {        if (_objectList.Count &gt; 0)        {            int index = Random.Range(0, _objectList.Count);            Destroy(_objectList[index].gameObject);            int lastIndex = _objectList.Count - 1;            _objectList[index] = _objectList[lastIndex];            _objectList.RemoveAt(lastIndex);        }    }    ...}</code></pre><p>大概思路就是下面这样，假设当前 List 中有 9 个对象<code>A-I</code>然后 <code>\0</code>代表结尾的话。</p><div class="table-container"><table><thead><tr><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">C</td><td style="text-align:center">D</td><td style="text-align:center">E</td><td style="text-align:center">F</td><td style="text-align:center">G</td><td style="text-align:center">H</td><td style="text-align:center">I</td><td style="text-align:center">\0</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">C</td><td style="text-align:center">D</td><td style="text-align:center">/</td><td style="text-align:center">F</td><td style="text-align:center">G</td><td style="text-align:center">H</td><td style="text-align:center"><strong>I</strong></td><td style="text-align:center">\0</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">C</td><td style="text-align:center">D</td><td style="text-align:center"><strong>I</strong></td><td style="text-align:center">F</td><td style="text-align:center">G</td><td style="text-align:center">H</td><td style="text-align:center">I</td><td style="text-align:center">\0</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">C</td><td style="text-align:center">D</td><td style="text-align:center"><strong>I</strong></td><td style="text-align:center">F</td><td style="text-align:center">G</td><td style="text-align:center">H</td><td style="text-align:center">\0</td><td style="text-align:center">-</td></tr></tbody></table></div><p>所以大概思路就是将<code>E</code>销毁掉以后，把 List 中的最后一个也就是<code>I</code>放到<code>E</code>原来的位置，然后再把<code>List</code>的最后一个移除这样。避免了大量的对象移动操作。完成以后看看效果～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018081900.gif" alt=""></p><h2 id="PART-3-自动化创建和销毁对象"><a href="#PART-3-自动化创建和销毁对象" class="headerlink" title="PART 3 自动化创建和销毁对象"></a>PART 3 自动化创建和销毁对象</h2><p>目前为止可以一键创建和销毁对象了，但是如果我们想要持续化的反复创建和销毁的话，一直敲键盘感觉会很累的样子，所以做一个小功能来自动化的创建和销毁比较好～所以我们可能需要创建一个拉杆允许我们调整生成和销毁的速度，总之随便用 UGUI 做一下就可以了～就像这样。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018081901.png" alt=""></p><p>然后我们需要做一些设置再添加一些代码让这个进度条工作起来。那么首先在<code>Game</code>中添加</p><pre><code class="lang-csharp">public class ReusingDemo : PersistableObject{    ...    public float CreationSpeed { get; set; }    public float DestructionSpeed { get; set; }    ...}</code></pre><p>我们需要设置这两个属性来接收 Slider 的值。像这样设置</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018081902.png" alt=""></p><p>除了下方的 On Value Changed 的地方设置好以外还要记得把 Max Value 改成 10，不然拖到最大每秒也只能生成一个就很慢。。。把两个 Slider 分别绑定到<code>CreationSpeed</code>和<code>DestructionSpeed</code>以后，继续添加代码：</p><pre><code class="lang-csharp">public class ReusingDemo : PersistableObject{    ...    public float CreationSpeed { get; set; }    public float DestructionSpeed { get; set; }    private float _creationProgress;    private float _destructionProgress;    ...    private void Update()    {        ...        _creationProgress += Time.deltaTime * CreationSpeed;        while (_creationProgress &gt;= 1f)        {            _creationProgress -= 1f;            CreateObject();        }        _destructionProgress += Time.deltaTime * DestructionSpeed;        while (_destructionProgress &gt;= 1f)        {            _destructionProgress -= 1f;            DestroyObject();        }    }    ...}</code></pre><p>大概思路。。。不用解释了吧这个代码也太简单了总之就累加到大于 1 就创建或者销毁就这样。。。那么运行一下看看效果吧～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018081903.gif" alt=""></p><h2 id="PART-4-对象池"><a href="#PART-4-对象池" class="headerlink" title="PART 4 对象池"></a>PART 4 对象池</h2><p>目前为止我们的准备工作终于完成了。在使用对象池之前，我们先打个包然后观察一下 Profiler 看看。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018081906.png" alt=""></p><p>跟之前一样打包并且勾选 Autoconnect Profiler 并且运行起来，把自动生成和销毁速度都调成最高，我们可以观察到每次 Instantiate 对象的时候都会导致 GC Alloc 的产生。因此我们要做的是使用对象池把要被销毁的对象保存起来以便下次再重用从而避免 GC Alloc。</p><p>众所周知对象池就是一个“池子”里面放着我们所需要的对象，在需要使用的时候从里面取出，发现取空的时候才创建对象。用完以后通过某个接口把对象重新放回池里。按照这个思路，我们针对<code>ShapeFactory</code>进行修改：</p><pre><code class="lang-csharp">[CreateAssetMenu]public class ShapeFactory : ScriptableObject{    ...    [SerializeField] private bool _recycle;    private List&lt;Shape&gt;[] _pools;    public Shape Get(int shapeId, int materialId)    {        Shape instance;        if (_recycle)        {            if (_pools == null)            {                CreatePools();            }            var pool = _pools[shapeId];            var lastIndex = pool.Count - 1;            if (lastIndex &gt;= 0)            {                instance = pool[lastIndex];                instance.gameObject.SetActive(true);                pool.RemoveAt(lastIndex);            }            else            {                instance = Instantiate(_prefabs[shapeId]);                instance.ShapeId = shapeId;            }        }        else        {            instance = Instantiate(_prefabs[shapeId]);            instance.ShapeId = shapeId;        }        instance.SetMaterial(_materials[materialId], materialId);        instance.SetColor(Random.ColorHSV(0f, 1f, 0.4f, 0.6f, 0.7f, 0.9f, 1f, 1f));        return instance;    }    ...    public void Reclaim(Shape shapeToRecycle)    {        if (_recycle)        {            if (_pools == null)            {                CreatePools();            }            _pools[shapeToRecycle.ShapeId].Add(shapeToRecycle);            shapeToRecycle.gameObject.SetActive(false);        }        else        {            Destroy(shapeToRecycle.gameObject);        }    }    private void CreatePools()    {        _pools = new List&lt;Shape&gt;[_prefabs.Length];        for (int i = 0; i &lt; _pools.Length; i++)        {            _pools[i] = new List&lt;Shape&gt;();        }    }}</code></pre><p>简单来说，就是我们为每种形状准备一个对象池，每次调用<code>Get()</code>获取一个新的 GameObject 的时候先检查对象池是否存在，确保对象池存在以后将 List 的最后一个对象返回。调用<code>Reclaim()</code>将一个正在被使用的对象放回 List 中，并设置<code>SetActive(false)</code>。</p><p>最后再修改本来销毁对象的地方，改成调用<code>Reclaim()</code>即可：</p><pre><code class="lang-csharp">public class ReusingDemo : PersistableObject{        ...    private void DestroyObject()    {        if (_objectList.Count &gt; 0)        {            int index = Random.Range(0, _objectList.Count);            shapeFactory.Reclaim(_objectList[index]);            int lastIndex = _objectList.Count - 1;            _objectList[index] = _objectList[lastIndex];            _objectList.RemoveAt(lastIndex);        }    }    private void BeginNewGame()    {        for (int i = 0; i &lt; _objectList.Count; i++)        {            shapeFactory.Reclaim(_objectList[i]);        }        _objectList.Clear();    }    ...}</code></pre><p>完成以后运行一下看看，发现运行一小段时间后不再有新的对象产生，而是通过已创建对象的反复开启和关闭来模拟创建和删除对象。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018081907.gif" alt=""></p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>嗯就这样完成了，话说之前好像有同学提醒说要再写详细一点不知道这一篇够不够详细，再贴一遍非常详细的『<a href="https://catlikecoding.com/unity/tutorials/object-management/reusing-objects/" target="_blank" rel="noopener">原文链接</a>』和我的『<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">项目地址</a>』方便大家看更详细的教程和下载代码直接跑～如果有需要交流的同学可以直接在我的<a href="https://snatix.com/2018/07/17/023-frames-per-second/">博客</a>的评论区留言这样我会更容易看到回复也会更快一些～好了不多说了我要继续跟室友联机群星继续我的银河帝国的征程了就酱～</p><hr><p>原文链接：<a href="https://snatix.com/2018/08/19/027-reusing-objects/">https://snatix.com/2018/08/19/027-reusing-objects/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      在 Unity 中使用对象池，使用 UGUI 创建和销毁对象。
    
    </summary>
    
      <category term="Catlike学习笔记" scheme="https://snatix.com/categories/Catlike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="教程" scheme="https://snatix.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="csharp" scheme="https://snatix.com/tags/csharp/"/>
    
      <category term="对象管理" scheme="https://snatix.com/tags/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Catlike学习笔记(2.2)-为不同颜色的GameObejct开启GPU Instancing</title>
    <link href="https://snatix.com/2018/08/08/026-object-variety/"/>
    <id>https://snatix.com/2018/08/08/026-object-variety/</id>
    <published>2018-08-08T14:40:48.000Z</published>
    <updated>2020-01-16T01:51:21.823Z</updated>
    
    <content type="html"><![CDATA[<p>20180808 过生日一大早就收到超级大红包开心～中午难得跟家人一起过生日所以晚上才开始写文章，今天来到了 <a href="https://catlikecoding.com/unity/tutorials/object-management/" target="_blank" rel="noopener">Object Management</a> 的第二篇 Object variety，在「<a href="https://snatix.com/2018/08/05/025-persisting-objects/">上一篇</a>」的基础上继续扩展，需要我们的存档文件支持保存不同形状和材质以及颜色的对象，并且在完成一系列功能后尝试开启 GPU Instancing 对比性能开销差异。</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>首先我们要对之前已经完成的工程进行一系列改进，当然如果只对 GPU Instancing 感兴趣的同学可以直接跳到 PART 5，我们需要逐步支持保存和加载不同形状，不同材质以及不同颜色的 GameObject，最终可以对比开启 GPU Instancing 以后的差异～所以大概有以下任务</p><ul><li>生成不同形状的 GameObject</li><li>支持保存和加载不同形状</li><li>支持多种材质和随机颜色</li><li>开启 GPU Instancing</li></ul><h2 id="PART-2-生成不同形状的-GameObject"><a href="#PART-2-生成不同形状的-GameObject" class="headerlink" title="PART 2 生成不同形状的 GameObject"></a>PART 2 生成不同形状的 GameObject</h2><p>那么为了实现这个需求我们需要继承在「<a href="https://snatix.com/2018/08/05/025-persisting-objects/">上一篇</a>」文章中实现的<code>PersistableObject</code>类，在上一篇中就有提到</p><blockquote><p>接下来<code>PersistableObject</code>的作用是挂载在 Perfab 上从而使得外部可以简单的通过<code>Save()</code>和<code>Load()</code>接口来将一个对象的所有数据一次性的保存或读取出来。后续如果我们不同种类的游戏对象需要保存和读取的数据更复杂的话就可以继承这个类并重写相关接口来实现而无需改动外部调用代码</p></blockquote><p>那么在这里因为多了一个定义形状的属性所以我们可以放心的继承这个类并且无需对以前的代码进行修改，为了符合「开闭原则」什么的就不提了～总之创建如下代码：</p><pre><code class="lang-csharp">public class Shape : PersistableObject{}</code></pre><p>新的<code>Shape</code>里面可以暂时什么都不需要添加等到我们需要加载和保存不同形状的时候再做。接下来我们创建一些各种形状的 Prefab 然后给他们挂上这个脚本，比如 Cube, Sphere 和 Capsule 像这样的三个 Prefab ～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080801.png" alt=""></p><p>然后我们还需要一个<code>ShapeFactory</code>类从而让我们可以通过调用一个接口生成不同的形状：</p><pre><code class="lang-csharp">using UnityEngine;[CreateAssetMenu]public class ShapeFactory : ScriptableObject{    [SerializeField] Shape[] prefabs;    public Shape Get (int shapeId) {        return Instantiate(prefabs[shapeId]);    }    public Shape GetRandom () {        return Get(Random.Range(0, prefabs.Length));    }}</code></pre><p>这个代码就很简单了大概就是 Instantiate 指定 Id 或者随机 Id 的形状，需要注意的是<code>CreateAssetMenu</code>选项可以让我们在 Project 窗口中任意文件夹点击右键创建这样的一个<code>ScriptableObject</code>。如果不是非常理解<code>ScriptableObject</code>的话大家可以简单的认为这个跟 Prefab 差不多只不过没有 GameObject 只有脚本中的各种属性被保存其中～更详细的解释大家可以参见「<a href="https://docs.unity3d.com/ScriptReference/ScriptableObject.html" target="_blank" rel="noopener">官方文档</a>」</p><p>然后我们右键创建一个<code>Shape Factory</code>然后把我们之前创建的 Prefab 拖进去如下图～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080802.png" alt=""></p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080803.png" alt=""></p><p>最后我们还需要稍微对之前写的<code>PersistentDemo</code>修改一下，博主为了方便在同一个工程中可以看到每一期的代码就新建一份名为<code>VarietyDemo</code>内容如下：</p><pre><code class="lang-csharp">public class VarietyDemo : PersistableObject{    public ShapeFactory shapeFactory;    ...    private void CreateObject()    {        Shape instance = shapeFactory.GetRandom();        var t = instance.transform;        t.localPosition = Random.insideUnitSphere * 5f;        t.localRotation = Random.rotation;        t.localScale = Vector3.one * Random.Range(0.1f, 1f);        _objectList.Add(instance);    }    private void BeginNewGame()    {        ...    }    public override void Save(GameDataWriter writer)    {        ...    }    public override void Load(GameDataReader reader)    {        int count = reader.ReadInt();        for (int i = 0; i &lt; count; i++)        {            Shape instance = shapeFactory.Get(0);            instance.Load(reader);            _objectList.Add(instance);        }    }}</code></pre><p>大家可以注意到，代码与昨天的<code>PersistentDemo</code>相差无无几，只有创建对象和加载的函数内部稍作修改，引用到了我们刚才写好的<code>ShapeFactory</code>和其函数<code>Get()</code>以及<code>GetRandom()</code>。那么此时我们运行一下会发现～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080804.gif" alt=""></p><p>虽然可以随机生成了但是我们只是保存了位置旋转和缩放信息，并没有保存具体是哪种形状，因此保存后再加载会发现所有的形状全都变成了 Cube。那么我们接下来该如何解决这个问题呢？</p><h2 id="PART-3-支持保存和加载不同形状"><a href="#PART-3-支持保存和加载不同形状" class="headerlink" title="PART 3 支持保存和加载不同形状"></a>PART 3 支持保存和加载不同形状</h2><p>那么首先为了支持旧版本的存档，也就是只有位置旋转和缩放信息的保存文件，需要引入版本号的概念～那么我们假设现在的版本号是1，我们需要做的是把版本号写到文件头部，加载存档的时候也先加载出来。所以修改<code>VarietyDemo</code>如下</p><pre><code class="lang-csharp">public class VarietyDemo : PersistableObject{    public int SaveVersion = 1;    ...    public override void Save(GameDataWriter writer)    {        writer.Write(-SaveVersion);        writer.Write(_objectList.Count);        ...    }    public override void Load(GameDataReader reader)    {        var version = -reader.ReadInt();        if (version &gt; SaveVersion) {            Debug.LogError(&quot;Unsupported future save version &quot; + version);            return;        }        int count = version &lt;= 0 ? -version : reader.ReadInt();        ...    }}</code></pre><p>因为我们之前的版本写入的是保存的对象的数量，因此为了方便区分版本号与数量，我们将版本号乘以<code>-1</code>以后再写入，这样就可以通过读出来的第一个数据是否大于<code>0</code>来确定是否是之前不带有版本号的版本，从而决定时候读取下一个 int 作为保存的对象的数量。那么有了版本号，接下来我们该把物体的形状保存下来～首先在<code>Shape</code>中添加以下代码</p><pre><code class="lang-csharp">public class Shape : PersistableObject{    private int _shapeId = int.MinValue;    public int ShapeId    {        get { return _shapeId; }        set        {            if (_shapeId == int.MinValue)            {                _shapeId = value;            }            else            {                Debug.LogError(&quot;Not allowed to change shapeId.&quot;);            }        }    }}</code></pre><p>总之就是在<code>Shape</code>中保存<code>ShapeId</code>，而且这个 Id 只能被赋值一次～完成以后继续修改<code>VarietyDemo</code>让我们每次在保存的时候把<code>ShapeId</code>写入文件，读取的时候根据<code>ShapeId</code>读取不同形状的 Prefab，代码如下</p><pre><code class="lang-csharp">public class VarietyDemo : PersistableObject{    ...    private List&lt;Shape&gt; _objectList;    ...    public override void Save(GameDataWriter writer)    {        writer.Write(-SaveVersion);        writer.Write(_objectList.Count);        for (int i = 0; i &lt; _objectList.Count; i++)        {            writer.Write(_objectList[i].ShapeId);            _objectList[i].Save(writer);        }    }    public override void Load(GameDataReader reader)    {        var version = -reader.ReadInt();        if (version &gt; SaveVersion) {            Debug.LogError(&quot;Unsupported future save version &quot; + version);            return;        }        int count = version &lt;= 0 ? -version : reader.ReadInt();        for (int i = 0; i &lt; count; i++)        {            var shapeId = version &lt;= 0 ? 0 : reader.ReadInt();            Shape instance = shapeFactory.Get(shapeId);            instance.Load(reader);            _objectList.Add(instance);        }    }}</code></pre><p>需要注意的是读取<code>ShapeId</code>之前先检查版本号，如果是负的版本号就表示我们并没有保存形状，所以就按照默认值 0 来处理～完成后我们运行一下看看，为了验证多版本支持功能正常运作，我们可以先运行一次上一篇文章创建的场景，保存一次再在新版本中载入试试。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080805.gif" alt=""></p><p>大家可以看到～我首先载入了旧版本的存档文件，生成出来的全是立方体，然后再按 C 创建了很多新的球体等其他形状的物体，保存后再加载，原来的立方体还是立方体，但是新的球体和胶囊体都保存下来了～</p><h2 id="PART-4-支持多种材质和随机颜色"><a href="#PART-4-支持多种材质和随机颜色" class="headerlink" title="PART 4 支持多种材质和随机颜色"></a>PART 4 支持多种材质和随机颜色</h2><p>在支持多材质和颜色之前，我们需要先重构一下存档版本的部分，因为方便起见我们最好可以在<code>Shape</code>类内部访问到要加载的存档版本，否则就被迫在<code>VarietyDemo</code>里面写处理所有版本相关的事情，非常的不直观。重构好以后我们就可以添加多个材质，在<code>ShapeFactory</code>中与形状一起处理，然后再在<code>Shape</code>中按照版本信息读取颜色，大概思路就是这样。</p><h3 id="重构版本管理部分"><a href="#重构版本管理部分" class="headerlink" title="重构版本管理部分"></a>重构版本管理部分</h3><p>，所以先修改<code>GameDataReader</code>使其在初始化的时候携带当前读取存档文件的版本号。当然还顺便加上了读颜色的接口方便后续操作。</p><pre><code class="lang-csharp">public class GameDataReader{    public int Version { get; private set; }    private BinaryReader _reader;    public GameDataReader(BinaryReader reader, int version)    {        _reader = reader;        Version = version;    }    ...    public Color ReadColor () {        Color value;        value.r = _reader.ReadSingle();        value.g = _reader.ReadSingle();        value.b = _reader.ReadSingle();        value.a = _reader.ReadSingle();        return value;    } }</code></pre><p>然后再修改<code>PersistentStorage</code>让我们每次保存的时候都先写入版本号，以及每次读取的时候都优先把版本号读出来。</p><pre><code class="lang-csharp">public class PersistentStorage : MonoBehaviour{    ...    public void Save(PersistableObject o, int version)    {        using (var writer = new BinaryWriter(File.Open(_savePath, FileMode.Create)))        {            writer.Write(-version);            o.Save(new GameDataWriter(writer));        }    }    public void Load(PersistableObject o)    {        using (var reader = new BinaryReader(File.Open(_savePath, FileMode.Open)))        {            o.Load(new GameDataReader(reader, -reader.ReadInt32()));        }    }}</code></pre><p>最后在<code>VarietyDemo</code>做相应的修改，大概在调用<code>Storage.Svae()</code>的时候把当前的版本号传入，然后去掉在保存时写入的版本号直接写对象数量，最后在<code>Load()</code>时可以从<code>reader.Version</code>读出版本号而无需自行<code>ReadInt()</code></p><pre><code class="lang-csharp">public class VarietyDemo : PersistableObject{    ...    private void Update()    {        ...        else if (Input.GetKeyDown(SaveKey))        {            Storage.Save(this, _saveVersion);        }        else if (Input.GetKeyDown(LoadKey))        {            BeginNewGame();            Storage.Load(this);        }    }    ...    public override void Save(GameDataWriter writer)    {        writer.Write(_objectList.Count);        ...    }    public override void Load(GameDataReader reader)    {        var version = reader.Version;        ...    }}</code></pre><p>总之一顿操作下来重构完成，运行一下试试有没有问题～博主这边表示完全正常。</p><h3 id="添加多材质和多颜色"><a href="#添加多材质和多颜色" class="headerlink" title="添加多材质和多颜色"></a>添加多材质和多颜色</h3><p>有了前面的铺垫这一步就很简单。那么首先我们需要在<code>GameDataReader</code>和<code>GameDataWriter</code>中分别添加读写<code>Color</code>的接口，从而我们可以在<code>Shape</code>中读写<code>Color</code>对象。</p><pre><code class="lang-csharp">public class GameDataReader{    ...    public Color ReadColor () {        Color value;        value.r = _reader.ReadSingle();        value.g = _reader.ReadSingle();        value.b = _reader.ReadSingle();        value.a = _reader.ReadSingle();        return value;    }}</code></pre><pre><code class="lang-csharp">public class GameDataWriter{    ...    public void Write (Color value) {        _writer.Write(value.r);        _writer.Write(value.g);        _writer.Write(value.b);        _writer.Write(value.a);    }}</code></pre><p>接下来在<code>Shape</code>中添加设置材质<code>SetMaterial()</code>和设置颜色<code>SetColor()</code>接口。从而可以在<code>ShapeFactory</code>中生成一个对象的时候为其设置随机材质和颜色。同时我们还需要 override <code>Save()</code>和<code>Load()</code>两个接口，从而读取和保存位于「位置」「旋转」和「缩放」之后的颜色属性。</p><pre><code class="lang-csharp">public class Shape : PersistableObject{    ...    public int MaterialId { get; private set; }    public Color Color { get; private set; }    public void SetMaterial(Material material, int materialId)    {        GetComponent&lt;MeshRenderer&gt;().material = material;        MaterialId = materialId;    }    public void SetColor(Color color)    {        GetComponent&lt;MeshRenderer&gt;().material.color = color;        Color = color;    }    public override void Save(GameDataWriter writer)    {        base.Save(writer);        writer.Write(Color);    }    public override void Load(GameDataReader reader)    {        base.Load(reader);        SetColor(reader.Version &lt;= 0 ? Color.white : reader.ReadColor());    }}</code></pre><p>然后创建三个材质球看起来不一样即可，博主按照「<a href="https://catlikecoding.com/unity/tutorials/object-management/object-variety/" target="_blank" rel="noopener">原文链接</a>」的指示选择了 Shandard Shiny Metallic，其中 Standard 就是默认的新建材质球，Shiny 是默认材质球把 Smoothness 拉到 0.9，Metallic 就是把 Metallic 和 Smoothness 同时拉到 0.9。创建好以后修改<code>ShapeFactory</code>如下~</p><pre><code class="lang-csharp">[CreateAssetMenu]public class ShapeFactory : ScriptableObject{    [SerializeField] private Shape[] _prefabs;    [SerializeField] private Material[] _materials;    public Shape Get(int shapeId, int materialId)    {        var instance = Instantiate(_prefabs[shapeId]);        instance.ShapeId = shapeId;        instance.SetMaterial(_materials[materialId], materialId);        return instance;    }    public Shape GetRandom()    {        var instance = Get(Random.Range(0, _prefabs.Length), Random.Range(0, _materials.Length));        instance.SetColor(Random.ColorHSV(0f, 1f, 0.4f, 0.6f, 0.7f, 0.9f, 1f, 1f));        return instance;    }}</code></pre><p>注意我们在<code>Get()</code>中添加一个参数并在<code>Instantiate()</code>后调用<code>SetMaterial()</code>用于设置材质球，以及在<code>GetRandom()</code>中调用的<code>SetColor()</code>从而设置随机颜色之类的～最后相应的修改<code>VarietyDemo</code>如下～</p><pre><code class="lang-csharp">public class VarietyDemo : PersistableObject{    ...    public override void Save(GameDataWriter writer)    {        writer.Write(_objectList.Count);        for (int i = 0; i &lt; _objectList.Count; i++)        {            writer.Write(_objectList[i].ShapeId);            writer.Write(_objectList[i].MaterialId);            _objectList[i].Save(writer);        }    }    public override void Load(GameDataReader reader)    {        ...        for (int i = 0; i &lt; count; i++)        {            var shapeId = version &lt;= 0 ? 0 : reader.ReadInt();            var materialId = version &lt;= 0 ? 0 : reader.ReadInt();            Shape instance = shapeFactory.Get(shapeId, materialId);            instance.Load(reader);            _objectList.Add(instance);        }    }}</code></pre><p>全部完成后我们尝试运行一下～因为代码跨越多个文件如果不能马上理顺其中的关系的话可以尝试自行实现一遍应该会很快理解～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080901.gif" alt=""></p><h2 id="PART-5-开启-GPU-Instancing"><a href="#PART-5-开启-GPU-Instancing" class="headerlink" title="PART 5 开启 GPU Instancing"></a>PART 5 开启 GPU Instancing</h2><p>那么开启 GPU Instancing 很简单只需要在 Material 中勾选 GPU Instancing 就可以了～就像下面这样。。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080902.png" alt=""></p><p>所以勾选了这个真的有效果么？</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080903.png" alt=""></p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080904.png" alt=""></p><p>那么我们注意到开启了 GPU Instancing 以后 Batches 从 402 降低到了 219，但事实上我们还有很多改进空间。因为默认的 Shadard Shader 中 Unity 只会将只有 Transform 组件不同的 GameObject 进行合批处理，因此改变颜色会导致该机制失效，那么我们首先创建一个支持将颜色声明为 instanced property 的 shader 使其支持不同颜色的 GameObject。代码如下~</p><pre><code class="lang-c++">Shader &quot;Custom/InstancedColors&quot; {    Properties {        _Color (&quot;Color&quot;, Color) = (1,1,1,1)        _MainTex (&quot;Albedo (RGB)&quot;, 2D) = &quot;white&quot; {}        _Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5        _Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0    }    SubShader {        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }        LOD 200        CGPROGRAM        #pragma surface surf Standard fullforwardshadows        #pragma instancing_options assumeuniformscaling        #pragma target 3.0        sampler2D _MainTex;        struct Input {            float2 uv_MainTex;        };        half _Glossiness;        half _Metallic;        UNITY_INSTANCING_BUFFER_START(Props)            UNITY_DEFINE_INSTANCED_PROP(fixed4, _Color)        UNITY_INSTANCING_BUFFER_END(Props)        void surf (Input IN, inout SurfaceOutputStandard o) {            fixed4 c = tex2D (_MainTex, IN.uv_MainTex) *                UNITY_ACCESS_INSTANCED_PROP(Props, _Color);            o.Albedo = c.rgb;            o.Metallic = _Metallic;            o.Smoothness = _Glossiness;            o.Alpha = c.a;        }        ENDCG    }    FallBack &quot;Diffuse&quot;}</code></pre><p>使用以上 Shader 时，我们需要使用<a href="http://docs.unity3d.com/Documentation/ScriptReference/MaterialPropertyBlock.html" target="_blank" rel="noopener"><code>MaterialPropertyBlock</code></a>将 _Color 属性的变化告诉 Unity 使其可以将这些 GameObject 置入同一个 draw call 中。修改<code>Shape</code>代码如下</p><pre><code class="lang-csharp">public class Shape : PersistableObject{    ...    private MeshRenderer _meshRenderer;    private static int _colorPropertyId = Shader.PropertyToID(&quot;_Color&quot;);    private static MaterialPropertyBlock _sharedPropertyBlock;    void Awake () {        _meshRenderer = GetComponent&lt;MeshRenderer&gt;();    }    public void SetMaterial(Material material, int materialId)    {        _meshRenderer.material = material;        MaterialId = materialId;    }    public void SetColor(Color color)    {        if (_sharedPropertyBlock == null) {            _sharedPropertyBlock = new MaterialPropertyBlock();        }        _sharedPropertyBlock.SetColor(_colorPropertyId, color);        _meshRenderer.SetPropertyBlock(_sharedPropertyBlock);        Color = color;    }    ...}</code></pre><p>最后再运行一下看看～效果显著！从 219 又降到 55 非常神奇～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018081001.png" alt=""></p><h2 id="PART-6-总结"><a href="#PART-6-总结" class="headerlink" title="PART 6 总结"></a>PART 6 总结</h2><p>又是持续两天写完的文章(<del>实际上有三天因为现在已经过 12 点了</del>)。。不管怎么说完成这篇文章以后博主自己还是稍微有一点点收获的，就是关于 GPU Instancing 的最最基础的使用的部分。这篇真的好长而且很多功能横跨几个文件，没太理顺的同学可以跳转「<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">Github项目地址</a>」下载工程亲自跑起来试一下会更容易理解～希望在假期结束之前也就是8月15号之前可以顺利完成「对象管理」的部分，加油～</p><hr><p>原文链接：<a href="https://snatix.com/2018/08/08/026-object-variety/">https://snatix.com/2018/08/08/026-object-variety/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      使用 Unity 生成并保存 GameObject 并为不同形状和颜色的 GameObject 开启 GPU Instancing
    
    </summary>
    
      <category term="Catlike学习笔记" scheme="https://snatix.com/categories/Catlike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="教程" scheme="https://snatix.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="csharp" scheme="https://snatix.com/tags/csharp/"/>
    
      <category term="对象管理" scheme="https://snatix.com/tags/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/"/>
    
      <category term="shader" scheme="https://snatix.com/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>Catlike学习笔记(2.1)-保存和加载GameObject</title>
    <link href="https://snatix.com/2018/08/05/025-persisting-objects/"/>
    <id>https://snatix.com/2018/08/05/025-persisting-objects/</id>
    <published>2018-08-05T14:40:48.000Z</published>
    <updated>2020-01-16T01:51:21.824Z</updated>
    
    <content type="html"><![CDATA[<p>终于放假回国了～然而热到爆炸几乎不能出门，充了B站大会员在家看了花了两天补完「<a href="https://www.bilibili.com/bangumi/media/md5978/?from=search&amp;seid=7643644285500463201" target="_blank" rel="noopener">博人传 火影忍者新时代</a>」和「<a href="https://www.bilibili.com/bangumi/media/md8812/?from=search&amp;seid=4918824649219054592" target="_blank" rel="noopener">齐木楠雄的灾难</a>」第二季，今天终于要开始努力学习了嗯。。。那么今天来到了「<a href="https://catlikecoding.com/unity/tutorials/" target="_blank" rel="noopener">Catlike教程</a>」的第二部分——<a href="https://catlikecoding.com/unity/tutorials/object-management/" target="_blank" rel="noopener">对象管理</a>，那么这是一系列与创建，追踪，保存和加载对象的教程。今天就不多说了快速进入正题～</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>既然做要保存和加载 GameObject 那么我们肯定要先做生成的功能，生成完以后保存下来，然后清除掉，再把之前保存的内容加载出来这样～所以我们的任务目标是以下这些：</p><ul><li>一键生成随机方块并一键清除</li><li>保存 GameObject 的状态写入文件</li><li>加载已经保存的数据重新生成 GameObject</li><li>重构一下将保存与加载抽象成独立模块</li></ul><h2 id="PART-2-完成游戏逻辑"><a href="#PART-2-完成游戏逻辑" class="headerlink" title="PART 2 完成游戏逻辑"></a>PART 2 完成游戏逻辑</h2><p>我们的需求非常简单，大概就是按下一个按键就生成一个小方块在随机位置旋转和缩放，然后按下某个按键就可以清空场景内所有方块。那么首先我们随便创建一个方块的 Prefab，然后创建脚本名为<code>PersistentDemo</code>然后添加如下代码。</p><pre><code class="lang-csharp">public class PersistentDemo : MonoBehaviour{    public Transform Prefab;    public KeyCode CreateKey = KeyCode.C;    private List&lt;Transform&gt; _objectList;    private void Awake()    {        _objectList = new List&lt;Transform&gt;();    }    private void Update()    {        if (Input.GetKeyDown(CreateKey))        {            CreateObject();        }    }    private void CreateObject()    {        Transform t = Instantiate(Prefab);        t.localPosition = Random.insideUnitSphere * 5f;        t.localRotation = Random.rotation;        t.localScale = Vector3.one * Random.Range(0.1f, 1f);        _objectList.Add(t);    }}</code></pre><p>代码特别简单大概就是在<code>Update()</code>中检测按键，然后在随机位置生成一个随机旋转和大小的方块，然后加到<code>ObjectList</code>中。写好以后我们在场景中创建一个空 GameObject 取名叫<code>Game</code>然后挂上该脚本，再把之前制作好的 Cube Prefab 拖到脚本中。运行一下看看～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080601.gif" alt="picture"></p><p>嗯效果不错～然后我们需要设置一个快捷键可以一键清除所有方块以便重新开始生成。那么继续添加如下代码。大概就是检测到玩家按下按键后就遍历<code>ObjectList</code>中的所有 GameObject 并 Destroy，最后清空<code>ObjectList</code>。</p><pre><code class="lang-csharp">using System.Collections.Generic;using UnityEngine;public class PersistentDemo : MonoBehaviour{    ...    public KeyCode NewGameKey = KeyCode.N;    ...    private void Update()    {        ...        else if (Input.GetKey(NewGameKey))        {            BeginNewGame();        }    }    ...    private void BeginNewGame()    {        for (int i = 0; i &lt; ObjectList.Count; i++)        {            Destroy(ObjectList[i].gameObject);        }        ObjectList.Clear();    }}</code></pre><p>运行效果就不截图了总之就是所有的小方块都消失了～那么我们现在就完成了第一步。</p><h2 id="PART-3-保存和读取"><a href="#PART-3-保存和读取" class="headerlink" title="PART 3 保存和读取"></a>PART 3 保存和读取</h2><p>保存和读取的思路非常简单，我们在这里就不用 PlayerPref 之类的东西，而是采取更简单易懂的直接在 PersistentData 目录中创建一个文件把 GameObject 的信息写在里面就好了。那么事实上我们需要保存的数据就只有方块的数量以及每个方块其各自的位置，旋转和大小。那么我们尝试在<code>PersistentDemo</code>中添加如下代码。</p><pre><code class="lang-csharp">public class PresistentDemo : MonoBehaviour{    ...    public KeyCode SaveKey = KeyCode.S;    private List&lt;Transform&gt; _objectList;    private string _savePath;    private void Awake()    {        _objectList = new List&lt;Transform&gt;();        _savePath = Path.Combine(Application.persistentDataPath, &quot;saveFile&quot;);    }    private void Update()    {        ...        else if (Input.GetKeyDown(SaveKey))        {            Save();        }    }    ...    private void Save()    {        using (var writer = new BinaryWriter(File.Open(_savePath, FileMode.Create)))        {            writer.Write(_objectList.Count);            for (int i = 0; i &lt; _objectList.Count; i++)            {                Transform t = _objectList[i];                writer.Write(t.localPosition.x);                writer.Write(t.localPosition.y);                writer.Write(t.localPosition.z);            }        }    }}</code></pre><p>代码内容也非常简单，大概就是检测按键后在预设好的路径中创建文件，然后写入当前创建的方块的数量，并依次写入每个方块的<code>Position</code>。这样一来读取的代码也呼之欲出了，大概就是从预设路径的文件中取出方块的数量最后按照相应的位置信息生成 GameObject </p><pre><code class="lang-csharp">public class PresistentDemo : MonoBehaviour{    ...    public KeyCode LoadKey = KeyCode.L;    ...    private void Update()    {        ...        else if (Input.GetKeyDown(LoadKey)) {            Load();        }    }    ...    private void Load()    {        BeginNewGame();        using (var reader = new BinaryReader(File.Open(_savePath, FileMode.Open)))        {            int count = reader.ReadInt32();            for (int i = 0; i &lt; count; i++)            {                Vector3 p;                p.x = reader.ReadSingle();                p.y = reader.ReadSingle();                p.z = reader.ReadSingle();                Transform t = Instantiate(Prefab);                t.localPosition = p;                _objectList.Add(t);            }        }    }}</code></pre><p>运行一下看看效果～在这里博主特意把按键指令也显示在屏幕左下角方便大家看清楚发生了什么～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080602.gif" alt="picture"></p><p>那么大家会注意到，最后按下<code>l</code>的时候，所有的小方块的旋转和缩放信息都不见了，只剩下位置还是正确的，那么讲道理我们可以继续修改代码把旋转和缩放也写到文件里面，不过这样代码会变得异常丑陋，我们稍微重构一下代码再把旋转和缩放补全吧。</p><h2 id="PART-4-抽象与重构"><a href="#PART-4-抽象与重构" class="headerlink" title="PART 4 抽象与重构"></a>PART 4 抽象与重构</h2><p>那么该如何抽象呢，大概的思路就是先创建一个<code>Writer</code>和<code>Reader</code>可以让我们方便的从<code>Binary</code>中读出<code>Vector3</code>和<code>Quaternion</code>，然后创建<code>PersistableObject</code>挂载在我们的 Prefab 上，可以使外部方便的调用<code>Save()</code>和<code>Load()</code>接口就可以把 Prefab 中的所有重要信息，如 Position Rotation Scale 等保存或读取出来。最后我们从<code>PresistentDemo</code>把保存和读取相关的代码提取出来单独作为一个<code>PersistentStorage</code>类，由<code>PresistentDemo</code>调用。那么方案确定下来以后就开始实施～</p><h3 id="Writer-和-Reader"><a href="#Writer-和-Reader" class="headerlink" title="Writer 和 Reader"></a>Writer 和 Reader</h3><p>Writer 和 Reader 的作用就是允许我们方便的调用一个接口就可以把相应比较复杂的数据结构写入到 Binary 中或从中读取，从而避免大量的重复的类似<code>writer.Write(t.localPosition.x)</code>这样的代码。这两部分代码非常相似而且很简单，就不多解释了随便贴一下。。。。</p><pre><code class="lang-csharp">public class GameDataReader{    private BinaryReader _reader;    public GameDataReader(BinaryReader reader)    {        _reader = reader;    }    public float ReadFloat()    {        return _reader.ReadSingle();    }    public int ReadInt()    {        return _reader.ReadInt32();    }    public Quaternion ReadQuaternion()    {        Quaternion value;        value.x = _reader.ReadSingle();        value.y = _reader.ReadSingle();        value.z = _reader.ReadSingle();        value.w = _reader.ReadSingle();        return value;    }    public Vector3 ReadVector3()    {        Vector3 value;        value.x = _reader.ReadSingle();        value.y = _reader.ReadSingle();        value.z = _reader.ReadSingle();        return value;    }}</code></pre><pre><code class="lang-csharp">public class GameDataWriter{    private BinaryWriter _writer;    public GameDataWriter(BinaryWriter writer)    {        _writer = writer;    }    public void Write(float value)    {        _writer.Write(value);    }    public void Write(int value)    {        _writer.Write(value);    }    public void Write(Quaternion value)    {        _writer.Write(value.x);        _writer.Write(value.y);        _writer.Write(value.z);        _writer.Write(value.w);    }    public void Write(Vector3 value)    {        _writer.Write(value.x);        _writer.Write(value.y);        _writer.Write(value.z);    }}</code></pre><h3 id="Persistable-Object"><a href="#Persistable-Object" class="headerlink" title="Persistable Object"></a>Persistable Object</h3><p>接下来<code>PersistableObject</code>的作用是挂载在 Perfab 上从而使得外部可以简单的通过<code>Save()</code>和<code>Load()</code>接口来将一个对象的所有数据一次性的保存或读取出来。后续如果我们不同种类的游戏对象需要保存和读取的数据更复杂的话就可以继承这个类并重写相关接口来实现而无需改动外部调用代码，不过这都是后话了，目前我们需要保存的就是<code>localPosition</code>，<code>localRotation</code>和<code>localScale</code>这样。所以代码如下</p><pre><code class="lang-csharp">[DisallowMultipleComponent]public class PersistableObject : MonoBehaviour{    public virtual void Save(GameDataWriter writer)    {        writer.Write(transform.localPosition);        writer.Write(transform.localRotation);        writer.Write(transform.localScale);    }    public virtual void Load(GameDataReader reader)    {        transform.localPosition = reader.ReadVector3();        transform.localRotation = reader.ReadQuaternion();        transform.localScale = reader.ReadVector3();    }}</code></pre><p>是不是这样组织代码比在 <code>PresistentDemo</code>中实现所有功能要清晰很多呢，而且很容易扩展和修改～最后不要忘记挂在我们的 Prefab 上面。</p><h3 id="Persistent-Storage"><a href="#Persistent-Storage" class="headerlink" title="Persistent Storage"></a>Persistent Storage</h3><p>最后<code>PersistentStorage</code>存在的意义是将文件操作相关代码从主逻辑中剥离出来，并没有很多内容。。。</p><pre><code class="lang-csharp">public class PersistentStorage : MonoBehaviour{    private string _savePath;    void Awake()    {        _savePath = Path.Combine(Application.persistentDataPath, &quot;saveFile&quot;);    }    public void Save(PersistableObject o)    {        using (var writer = new BinaryWriter(File.Open(_savePath, FileMode.Create)))        {            o.Save(new GameDataWriter(writer));        }    }    public void Load(PersistableObject o)    {        using (var reader = new BinaryReader(File.Open(_savePath, FileMode.Open)))        {            o.Load(new GameDataReader(reader));        }    }}</code></pre><p>将其挂在 Game 上后修改<code>PresistentDemo</code>，完整代码如下～注意我们 Override 的<code>Save()</code>和<code>Load()</code>函数部分。以及按下 SaveKey 和 LoadKey 后调用的<code>Storage.Save(this)</code>和<code>Storage.Load(this)</code></p><pre><code class="lang-csharp">public class PresistentDemo : PersistableObject{    public PersistableObject Prefab;    public KeyCode CreateKey = KeyCode.C;    public KeyCode NewGameKey = KeyCode.N;    public KeyCode SaveKey = KeyCode.S;    public KeyCode LoadKey = KeyCode.L;    private List&lt;PersistableObject&gt; _objectList;    public PersistentStorage Storage;    private void Awake()    {        _objectList = new List&lt;PersistableObject&gt;();    }    private void Update()    {        if (Input.GetKeyDown(CreateKey))        {            CreateObject();        }        else if (Input.GetKey(NewGameKey))        {            BeginNewGame();        }        else if (Input.GetKeyDown(SaveKey))        {            Storage.Save(this);        }        else if (Input.GetKeyDown(LoadKey))        {            BeginNewGame();            Storage.Load(this);        }    }    private void CreateObject()    {        PersistableObject o = Instantiate(Prefab);        var t = o.transform;        t.localPosition = Random.insideUnitSphere * 5f;        t.localRotation = Random.rotation;        t.localScale = Vector3.one * Random.Range(0.1f, 1f);        _objectList.Add(o);    }    private void BeginNewGame()    {        for (int i = 0; i &lt; _objectList.Count; i++)        {            Destroy(_objectList[i].gameObject);        }        _objectList.Clear();    }    public override void Save(GameDataWriter writer)    {        writer.Write(_objectList.Count);        for (int i = 0; i &lt; _objectList.Count; i++)        {            _objectList[i].Save(writer);        }    }    public override void Load(GameDataReader reader)    {        int count = reader.ReadInt();        for (int i = 0; i &lt; count; i++)        {            PersistableObject o = Instantiate(Prefab);            o.Load(reader);            _objectList.Add(o);        }    }}</code></pre><p>最后把各种东西引用都拖好大概像这样～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080603.png" alt="picture"></p><p>最后运行下看看～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018080604.gif" alt="picture"></p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>持续一边划水玩手机一边吃零食一边写文章花了两天终于完成了～自己回顾下来感觉代码有点多讲的不够细，但是都是非常简单的代码呀相信各位同学可以轻轻松松搞定的～嗯明天就开始下一篇！哦对了差点忘记顺手贴上「<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">Github项目地址</a>」，懒得自己码代码的同学可以下载下来直接运行哦～</p><hr><p>原文链接：<a href="https://snatix.com/2018/08/05/025-persisting-objects/">https://snatix.com/2018/08/05/025-persisting-objects/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      在Unity中随机生成GameObject并将数据保存至 PersistentData 并加载。
    
    </summary>
    
      <category term="Catlike学习笔记" scheme="https://snatix.com/categories/Catlike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="教程" scheme="https://snatix.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="csharp" scheme="https://snatix.com/tags/csharp/"/>
    
      <category term="对象管理" scheme="https://snatix.com/tags/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>重启Hexo(4)-使用travis-ci部署到Github和Coding</title>
    <link href="https://snatix.com/2018/07/28/024-use-travis-deploy-hexo/"/>
    <id>https://snatix.com/2018/07/28/024-use-travis-deploy-hexo/</id>
    <published>2018-07-27T23:59:48.000Z</published>
    <updated>2020-01-16T01:51:21.824Z</updated>
    
    <content type="html"><![CDATA[<p>这周末要看 PUBG 的 PGI 比赛了，刚好在柏林举办受人之托去领一个饰品之类的所以时间非常紧所以『<a href="https://snatix.com/categories/Catlike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Catlike学习笔记</a>』系列就先停更一个礼拜～写一篇比较简单的 Hexo 相关教程。其实之前就想写了，因为 Hexo 一直要从同一台设备部署，如果刚好手边没有设备又想改点什么东西又不想重新装一遍环境就很烦。。所以就想到用免费的 <a href="https://travis-ci.org/sNaticY/hexo-blog/builds/408490063" target="_blank" rel="noopener">travis-ci</a> 来帮助我们进行持续集成。这样甚至可以随时随地打开网页版 Github 修改文章非常方便～甚至还可以自动部署到 <a href="https://coding.net/" target="_blank" rel="noopener">coding.net</a> 上从而大幅度提高国内用户的访问速度。</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>作为「<a href="https://snatix.com/categories/Hexo%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF%E8%AE%A1%E5%88%92/">Hexo博客重启计划</a>」的第四篇，我们就不详细讲解如何搭建 Hexo 或者选择主题了，默认大家本地都有环境而且都已经部署好全部东西了，如果还没有的话欢迎移步「<a href="https://snatix.com/2017/01/08/007-install-hexo-on-mac/">重启Hexo(1)-在Mac上安装Hexo</a>」安装与部署教程，以及「<a href="https://snatix.com/2017/01/14/008-customize-hexo/">重启Hexo(2)-Material深度探索</a>」主题相关教程。那么我们今天的任务有以下几个</p><ul><li>关联 Travis-CI 与 Github，并使用 Travis-CI 进行 Build</li><li>添加 push 到 Github pages 完成自动部署</li><li>添加 push 到 coding.net 完成自动部署</li></ul><h2 id="PART-2-关联-Travis-CI-与-Github"><a href="#PART-2-关联-Travis-CI-与-Github" class="headerlink" title="PART 2 关联 Travis-CI 与 Github"></a>PART 2 关联 Travis-CI 与 Github</h2><p>关于 Travis-CI 具体介绍我们就不多讲了，想要了解更多的同学自行查找资料～我们首先需要进入 Travis-CI 注册帐号，一般来说只需要选择「使用 Github 帐号登录」就可以了完成所有关联了～此时大概会显示如下页面</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072802.png" alt="picture"></p><p>选择你的 Hexo 源码托管的仓库开启并点击<code>Settings</code>，只需勾选<code>Build Pushed Branches</code>其他的取消就好，不然其他人的 Pull Request 也会导致博客更新会容易出问题。。。如图所示</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072803.png" alt="picture"></p><p>最后在你的仓库根目录中添加<code>.travis.yml</code>文件如下</p><pre><code class="lang-yaml">language: node_jsnode_js: stablebranches:  only:  - masterbefore_install:- git config --global user.name &quot;[你的Github帐号名]&quot;- git config --global user.email &quot;[你的Github邮箱]&quot;- npm install -g hexo-cliinstall:- npm iscript:- hexo clean- hexo generate</code></pre><p>完成以后将代码 Push 到 Github 上会发现已经可以自动 Build 了，关联成功的话 Build 过程中大概会这样。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072804.png" alt="picture"></p><p>最后 Build 成功的话会在下方的 Log 中显示，这样一来我们的 Github 就与 Travis-CI 的关联完成了～</p><pre><code class="lang-bash">The command &quot;hexo generate&quot; exited with 0.Done. Your build exited with 0.</code></pre><h2 id="PART-3-Push到Github-Pages完成自动部署"><a href="#PART-3-Push到Github-Pages完成自动部署" class="headerlink" title="PART 3 Push到Github Pages完成自动部署"></a>PART 3 Push到Github Pages完成自动部署</h2><p>目前为止我们的 Travis-CI 具备了编译 Hexo 博客的能力，通过执行<code>hexo generate</code>指令将一大堆东西生成到<code>./public</code>目录中。按照通常方法我们会使用 hexo deploy 指令发布到固定的 Github Pages 仓库中。但这里似乎容易出现一些麻烦的问题，所以博主在这里采取了直接初始化仓库并强制提交的方法，简单粗暴不用改一堆配置，只需在之前创建的<code>.travis.yml</code>最后添加如下代码</p><pre><code class="lang-yaml">after_success:- cd ./public- git init- git add --all .- git commit -m &quot;Travis CI Auto Builder&quot;- git push --quiet --force https://$REPO_TOKEN@[托管Hexo的Github Pages的仓库地址] master:master</code></pre><p>前面四行代码大家都很容易理解，那么最后一行代码的「托管Hexo的Github Pages的仓库地址」是什么呢，比如说博主的 Hexo 仓库地址是<code>https://github.com/sNaticY/blog.git</code>，那么就最后一行就是<code>- git push --quiet --force https://$REPO_TOKEN@github.com/sNaticY/blog.git master:master</code>。大家还可以根据自身仓库状况修改要 Push 的分支之类的。</p><p>那么在这个之前出现的<code>$REPO_TOKEN</code>又是什么呢？首先我们的 Travis-CI 虽然获得了授权可以将所有的 Public 仓库的代码 Pull 下来进行编译，但是并没有权限 Push 代码，我们又不方便把密码或者 Token 之类的关键信息明文的写在 Public 仓库中的文件里。所以此处需要设置 <strong>Environment Variables</strong>。</p><p>首先进入 Github 点击自己的头像依次进入<code>Settings / Developer Settings / Personal access tokens</code>，点击<code>Generate new token</code>并设置名字勾选 Repo 相关权限，如图所示</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072806.png" alt="picture"></p><p>生成后复制 Token 并打开之前的 Settings 页面找到下图所示的位置，在<code>Name</code>框中输入<code>REPO_TOKEN</code>并将 Token 粘贴到<code>Value</code>框中。然后点击 Add。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072805.png" alt="picture"></p><p>那么我们之前在<code>.travis.yml</code>中添加的<code>$REPO_TOKEN</code>就表示在该命令执行时自动调用此处的 Token 以确保仓库权限安全。全部完成后将<code>.travis.yml</code>提交到 Github，等待一小会儿如果 Log 最后扔显示<code>Done. Your build exited with 0.</code> 表示一切功能运行正常。打开你的博客看看，是不是已经生效了～</p><h2 id="PART-4-同时Push到Coding-net"><a href="#PART-4-同时Push到Coding-net" class="headerlink" title="PART 4 同时Push到Coding.net"></a>PART 4 同时Push到Coding.net</h2><p>具体新建仓库，创建 Coding Pages 绑定自定义域名之类的就不说了，我们的目标是让 Travis-CI 获得推送的权限，这样就可以直接 push 到 Coding Pages 的仓库完成部署。那么如何让 Travis-CI 获得权限呢？首先打开 <a href="https://coding.net/" target="_blank" rel="noopener">Coding.net</a> 点击右上角头像依次进入<code>我的帐号 / 访问令牌</code>并点击<code>新建令牌</code>，勾选<code>project:depot</code></p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072807.png" alt="picture"></p><p>生成后与之前相同的方法设置 <strong>Environment Variables</strong>，设置<code>Name</code>为<code>CODING_TOKEN</code>。最后再在<code>.travis.yml</code>最后添加一行：</p><pre><code class="lang-yaml">- git push --quiet --force https://[Coding用户名]:$CODING_TOKEN@[你的Coding Pages仓库] master:master</code></pre><p>提交后就发现任何时候提交到 Github 上的改动都会自动经过 Travis-CI 编译生成好并 Push 到 Github 和 Coding 上，让你可以随时随地在 Github 网页上修改文章并重新发布。</p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>本来想讲设置 DNS 的但是觉得跟第一篇教程有很多相同的东西显得非常重复就不浪费大家的时间了～不会设置的同学可以移步「<a href="https://snatix.com/2017/01/08/007-install-hexo-on-mac/">重启Hexo(1)-在Mac上安装Hexo</a>」寻找 DNS 设置的方法。只需在 DNS 中区分国内国外的 IP 然后分别设置到 Github 和 Coding 就好了很简单～希望可以对大家有所帮助，下个礼拜回国休息几天希望可以多写几篇博客，嗯就这样大家拜拜～</p><hr><p>原文链接：<a href="https://snatix.com/2018/07/28/024-use-travis-deploy-hexo/">https://snatix.com/2018/07/28/024-use-travis-deploy-hexo/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      使用travis-ci部署Hexo博客到Github pages, 使用travis-ci部署Hexo博客到Coding Pages, Hexo博客持续集成, 自动部署Hexo博客
    
    </summary>
    
      <category term="Hexo博客重启计划" scheme="https://snatix.com/categories/Hexo%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="github" scheme="https://snatix.com/tags/github/"/>
    
      <category term="hexo" scheme="https://snatix.com/tags/hexo/"/>
    
      <category term="coding" scheme="https://snatix.com/tags/coding/"/>
    
      <category term="travis" scheme="https://snatix.com/tags/travis/"/>
    
      <category term="部署" scheme="https://snatix.com/tags/%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>Catlike学习笔记(1.5)-使用Unity模拟原子核</title>
    <link href="https://snatix.com/2018/07/17/023-frames-per-second/"/>
    <id>https://snatix.com/2018/07/17/023-frames-per-second/</id>
    <published>2018-07-17T14:40:48.000Z</published>
    <updated>2020-01-16T01:51:21.823Z</updated>
    
    <content type="html"><![CDATA[<p>周末打了两天 Celeste 蔚蓝终于打穿了，作为 IGN 2018 年首款满分神作还是很名副其实的，至少关卡设计绝对是大师级的～虽然难到爆炸但是总有一种我刚才是失误下一次一定过的错觉。。事实证明像博主这样的手残党也可以在经历十几个小时的磨难后顺利通关～总的来说还是很赞的游戏，十几个小时的游戏时间绝对值回票价~是的没错说了这么多就是为了完美的解释上周末没有更新文章的原因。。好吧总之这周来到了「<a href="https://catlikecoding.com/unity/tutorials/basics/" target="_blank" rel="noopener">Catlike Coding 第一章</a>」的最后一篇文章～这篇主要是讲如何使用 Profiler 查看游戏的性能以及写个小工具测量帧率～按照惯例附上『<a href="https://catlikecoding.com/unity/tutorials/frames-per-second/" target="_blank" rel="noopener">原文链接</a>』</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>那么为了使用 Profiler 之类的工具可以有效的查看到性能的变化～我们需要制作一个跑得越来越慢的 Demo 的样子。。所以用 Unity 物理组件模拟一个不断增长的原子核似乎是个不错的想法。所以我们的目标大概有以下这些～</p><ul><li>使用 Unity 物理组件模拟原子核并使其不断增长</li><li>使用 Profiler 查看游戏性能并稍加分析</li><li>制作一个 FPS 指示器实时显示当前 FPS</li></ul><p>感觉需求并不是非常复杂～开工！</p><h2 id="PART-2-制作模拟原子核"><a href="#PART-2-制作模拟原子核" class="headerlink" title="PART 2 制作模拟原子核"></a>PART 2 制作模拟原子核</h2><p>我们并没有打算制作完全符合物理学的原子核模型～只是一些会被吸引到原点的小球而已跟真正的原子核一点关系都没有只是很有趣。所以第一步就是制作两个不同颜色的小球的 Prefab 一个代表质子另一个代表中子这样。首先我们制作一个脚本可以给小球一个由其当前位置指向世界坐标原点的力。</p><pre><code class="lang-csharp">[RequireComponent(typeof(Rigidbody))]public class Nucleon : MonoBehaviour{    public float AttractionForce;    private Rigidbody _body;    private void Awake()    {        _body = GetComponent&lt;Rigidbody&gt;();    }    private void FixedUpdate()    {        _body.AddForce(transform.localPosition * -AttractionForce);    }}</code></pre><p>大概就是这样～代码非常简单想必大家都看得懂就不解释了。。。接下来做两个不同颜色的 Material 以便区分质子和中子～比如像这样：</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018071701.png" alt="picture"></p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018071702.png" alt="picture"></p><p>最后把这些东西拼在一起做成 Prefab。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018071703.png" alt="picture"></p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018071704.png" alt="picture"></p><p>完成质子和中子的 Prefab 以后我们就可以生成这些质子和中子了，添加一个空 GameObject 并挂上以下代码</p><pre><code class="lang-csharp">public class NucleonSpawner : MonoBehaviour{    public float TimeBetweenSpawns;    public float SpawnDistance;    public Nucleon[] NucleonPrefabs;    private float _timeSinceLastSpawn;    private void FixedUpdate()    {        _timeSinceLastSpawn += Time.deltaTime;        if (_timeSinceLastSpawn &gt;= TimeBetweenSpawns)        {            _timeSinceLastSpawn -= TimeBetweenSpawns;            SpawnNucleon();        }    }    private void SpawnNucleon()    {        var prefab = NucleonPrefabs[Random.Range(0, NucleonPrefabs.Length)];        var spawn = Instantiate&lt;Nucleon&gt;(prefab);        spawn.transform.localPosition = Random.onUnitSphere * SpawnDistance;    }}</code></pre><p>最后再设置好合适的参数就可以了～比如这样：</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018071705.png" alt="picture"></p><p>到此为止我们的原子核生成器就完成了～运行效果如图所示：</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018071706.gif" alt="picture"></p><h2 id="PART-3-使用-Profiler-分析性能"><a href="#PART-3-使用-Profiler-分析性能" class="headerlink" title="PART 3 使用 Profiler 分析性能"></a>PART 3 使用 Profiler 分析性能</h2><p>我们一边运行一边打开 Profiler 看看～发现大概是下图的样子，博主用 Macbook 做的实验因此可以看到偶尔物理处理的部分那根柱子爆表了。。。以及偶尔会出现的 EditorOverhead 之类的干扰项。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072203.png" alt="picture"></p><p>我们可以在 Profiler 里面找到很多相关的数据但是并不十分准确～可以尝试打包以后再连接 Profiler 查看更准确的数据。要记得勾选<code>Development Build</code>和<code>Autoconnect Profiler</code>。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072204.png" alt="picture"></p><p>运行程序再在 Profiler 里面选择正确的要调试的应用。可以看到数据不像在 Editor 里那样疯狂跳动而是变得平滑一些。当然各项消耗的占比也会略有不同，有兴趣的话还可以尝试安卓或 ios 看看是不是会有更显著的差距。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072205.png" alt="picture"></p><h2 id="PART-4-计算FPS"><a href="#PART-4-计算FPS" class="headerlink" title="PART 4 计算FPS"></a>PART 4 计算FPS</h2><p>首先我们简单的制作一个显示当前 FPS 的脚本，大概代码如下所示</p><pre><code class="lang-csharp">public class FPSDisplay : MonoBehaviour{    [SerializeField] private Text _fpsText;    // Update is called once per frame    void Update()    {        _fpsText.text = ((int)(1f / Time.unscaledDeltaTime)).ToString();    }}</code></pre><p>然后发现，我们每一帧把 int 转换成 string 都会产生一些额外的 GC 开销，</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072206.png" alt="picture"></p><p>因此我们尝试提前建立 int 到 string 的索引，首先把帧数显示限制在 0-100 的范围内，然后从 List 中取出相应的字符串。</p><pre><code class="lang-csharp">public class FPSDisplay : MonoBehaviour{    [SerializeField] private Text _fpsText;    private static readonly List&lt;string&gt; _fpsStrings = new List&lt;string&gt;    {        &quot;00&quot;, &quot;01&quot;, &quot;02&quot;, &quot;03&quot;, &quot;04&quot;, &quot;05&quot;, &quot;06&quot;, &quot;07&quot;, &quot;08&quot;, &quot;09&quot;,        &quot;10&quot;, &quot;11&quot;, &quot;12&quot;, &quot;13&quot;, &quot;14&quot;, &quot;15&quot;, &quot;16&quot;, &quot;17&quot;, &quot;18&quot;, &quot;19&quot;,        &quot;20&quot;, &quot;21&quot;, &quot;22&quot;, &quot;23&quot;, &quot;24&quot;, &quot;25&quot;, &quot;26&quot;, &quot;27&quot;, &quot;28&quot;, &quot;29&quot;,        &quot;30&quot;, &quot;31&quot;, &quot;32&quot;, &quot;33&quot;, &quot;34&quot;, &quot;35&quot;, &quot;36&quot;, &quot;37&quot;, &quot;38&quot;, &quot;39&quot;,        &quot;40&quot;, &quot;41&quot;, &quot;42&quot;, &quot;43&quot;, &quot;44&quot;, &quot;45&quot;, &quot;46&quot;, &quot;47&quot;, &quot;48&quot;, &quot;49&quot;,        &quot;50&quot;, &quot;51&quot;, &quot;52&quot;, &quot;53&quot;, &quot;54&quot;, &quot;55&quot;, &quot;56&quot;, &quot;57&quot;, &quot;58&quot;, &quot;59&quot;,        &quot;60&quot;, &quot;61&quot;, &quot;62&quot;, &quot;63&quot;, &quot;64&quot;, &quot;65&quot;, &quot;66&quot;, &quot;67&quot;, &quot;68&quot;, &quot;69&quot;,        &quot;70&quot;, &quot;71&quot;, &quot;72&quot;, &quot;73&quot;, &quot;74&quot;, &quot;75&quot;, &quot;76&quot;, &quot;77&quot;, &quot;78&quot;, &quot;79&quot;,        &quot;80&quot;, &quot;81&quot;, &quot;82&quot;, &quot;83&quot;, &quot;84&quot;, &quot;85&quot;, &quot;86&quot;, &quot;87&quot;, &quot;88&quot;, &quot;89&quot;,        &quot;90&quot;, &quot;91&quot;, &quot;92&quot;, &quot;93&quot;, &quot;94&quot;, &quot;95&quot;, &quot;96&quot;, &quot;97&quot;, &quot;98&quot;, &quot;99&quot;    };    // Update is called once per frame    void Update()    {        var curFps = Mathf.Clamp((int) (1f / Time.unscaledDeltaTime), 0, 99);        _fpsText.text = _fpsStrings[curFps];    }}</code></pre><p>再次使用 Profiler 发现讨厌的 GC 消失不见了~</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072208.png" alt="picture"></p><p>不过我们的 FPS 指示器还有另外一个缺陷，就是每帧都在跳动如果变化非常剧烈的话基本上看不清显示的是什么，尽管我们可以改成每秒计算一次之类的，不过这样就没有办法感受到 FPS 在一秒之内产生怎样的变化。因此我们的做法就是求一定过去一定帧数之内的平均值。</p><pre><code class="lang-csharp">public class FPSDisplay : MonoBehaviour{    [SerializeField] private Text _fpsText;    [SerializeField] private int _fpsRange = 60;    private int[] _fpsBuffer;    private int _fpsBufferIndex;    ...    private void Awake()    {        _fpsBuffer = new int[_fpsRange];    }    // Update is called once per frame    private void Update()    {        UpdateBuffer();        CalcFPS();    }    private void UpdateBuffer()    {        var curFps = (int) (1f / Time.unscaledDeltaTime);        _fpsBuffer[_fpsBufferIndex] = curFps;        _fpsBufferIndex++;        if (_fpsBufferIndex &gt;= _fpsRange)        {            _fpsBufferIndex = 0;        }    }    private void CalcFPS()    {        var sum = 0;        foreach (var fps in _fpsBuffer)        {            sum += fps;        }        _fpsText.text = _fpsStrings[Mathf.Clamp(sum / _fpsRange, 0, 99)];    }}</code></pre><p>这样就可以求过去 60 帧之内的 FPS 的平均值了。我们还可以顺手把过去 60 帧之内的最大最小 FPS 分别显示出来，稍微改一改 UI 增加两个 Text 分别用于显示最大和最小值再修改代码如下：</p><pre><code class="lang-csharp">public class FPSDisplay : MonoBehaviour{    [SerializeField] private Text _lowFpsText;    [SerializeField] private Text _fpsText;    [SerializeField] private Text _highFpsText;    [SerializeField] private int _fpsRange = 60;    ...    private void CalcFPS()    {        var lowest = int.MaxValue;        var highest = 0;        var sum = 0;        foreach (var fps in _fpsBuffer)        {            if (fps &lt; lowest)            {                lowest = fps;            }            if (fps &gt; highest)            {                highest = fps;            }            sum += fps;        }        _lowFpsText.text = _fpsStrings[Mathf.Clamp(lowest, 0, 99)];        _fpsText.text = _fpsStrings[Mathf.Clamp(sum / _fpsRange, 0, 99)];        _highFpsText.text = _fpsStrings[Mathf.Clamp(highest, 0, 99)];    }}</code></pre><p>这样我们就可以愉快的把一定时间内最大最小以及平均 FPS 显示出来了～效果不错。。。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072209.png" alt="picture"></p><p>最后我们为不同数值范围的 FPS 上色，使得玩家可以更直观的感受到当前 FPS 正常还是过低。首先添加一个 Struct 里面保存一个颜色以及该颜色对应最低 FPS 值。</p><pre><code class="lang-csharp">[Serializable]struct FPSColor {    public Color color;    public int minimumFPS;}</code></pre><p>然后再稍微重构一下代码，在<code>CalcFps()</code>中每帧计算出来的 FPS 保存在类的成员变量中记录下来，然后把显示 FPS 的代码提取出来变成一个函数<code>DisplayFps()</code>每帧调用，分别用于刷新三个 Text 组件的颜色以及 FPS 数值。</p><pre><code class="lang-csharp">public class FPSDisplay : MonoBehaviour{    ...    [SerializeField] private int _fpsRange = 60;    [SerializeField] private FPSColor[] _fpsColors;    private int _lowFps;    private int _averageFps;    private int _highFps;    private int[] _fpsBuffer;    private int _fpsBufferIndex;    ...    private void Update()    {        UpdateBuffer();        CalcFps();        DisplayFps(_lowFpsText, _lowFps);        DisplayFps(_averageFpsText, _averageFps);        DisplayFps(_highFpsText, _highFps);    }    ...    private void CalcFps()    {        ...        _lowFps = lowest;        _averageFps = sum / _fpsRange;        _highFps = highest;    }    private void DisplayFps(Text label, int fps)    {        label.text = _fpsStrings[Mathf.Clamp(fps, 0, 99)];        for (var i = 0; i &lt; _fpsColors.Length; i++) {            if (fps &lt; _fpsColors[i].minimumFPS) continue;            label.color = _fpsColors[i].color;            break;        }    }}</code></pre><p>最后再在 Inspector 里设置好各种颜色如图所示：</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072210.png" alt="picture"></p><p>这样一个完美的 FPS 指示器就完成了～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018072211.png" alt="picture"></p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>至此「<a href="https://catlikecoding.com/unity/tutorials/basics/" target="_blank" rel="noopener">Catlike Coding 第一章</a>」内容已经全部结束～目前为止都是非常基础的课程，博主大部分时间都是在整理文字并没有花太多时间在 Unity 和 c# 上，很多地方也都是大概看一下原作者的思路就差不多自己去实现了并没有完全照搬代码，根据自己的理解写一遍下来感觉还是收获颇丰的虽然很多地方有点懒就跳过了，尤其是关于 Profiler 的部分感觉有些枯燥而且博主水平有限就没有深入，感兴趣或者有不太清楚的同学可以自行前往『<a href="https://catlikecoding.com/unity/tutorials/frames-per-second/" target="_blank" rel="noopener">原文链接</a>』寻找更详细的讲解。顺便补上「<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">Github项目地址</a>」，懒得码代码的同学可以直接下载下来运行哦～希望下一篇文章不要再拖更两个礼拜了嗯就这样～</p><hr><p>原文链接：<a href="https://snatix.com/2018/07/17/023-frames-per-second/">https://snatix.com/2018/07/17/023-frames-per-second/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      Catlike Coding, Unity模拟原子核, Unity基础教程, Unity项目Fps统计
    
    </summary>
    
      <category term="Catlike学习笔记" scheme="https://snatix.com/categories/Catlike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="教程" scheme="https://snatix.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="基础" scheme="https://snatix.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="csharp" scheme="https://snatix.com/tags/csharp/"/>
    
  </entry>
  
  <entry>
    <title>Catlike学习笔记(1.4)-使用Unity构建分形</title>
    <link href="https://snatix.com/2018/07/07/022-constructing-a-fractal/"/>
    <id>https://snatix.com/2018/07/07/022-constructing-a-fractal/</id>
    <published>2018-07-07T17:42:15.000Z</published>
    <updated>2020-01-16T01:51:21.824Z</updated>
    
    <content type="html"><![CDATA[<p>又两个星期没写文章了，主要是沉迷 <a href="https://store.steampowered.com/app/464350/Screeps/" target="_blank" rel="noopener">Screeps</a> 这个游戏，真的是太好玩了导致我这两个礼拜 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">Github</a> 小绿点几乎天天刷。其实想开一个新坑大概把自己写 AI 的心路历程记录下，不过觉得因为要消耗太多时间暂时决定先不开，准备把过程中遇到的有趣的算法问题记录下就好了。言归正传今天来到「<a href="https://catlikecoding.com/unity/tutorials/constructing-a-fractal/" target="_blank" rel="noopener">构建分形</a>」 这篇文章。比较简单主要介绍递归的思想。我们就迅速一些，<del>因为我还要继续沉迷 Screeps，</del>因为还要继续学习嗯。。。再贴一次「<a href="https://catlikecoding.com/unity/tutorials/constructing-a-fractal/" target="_blank" rel="noopener">原文链接</a>」吧。。</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>「<a href="https://en.wikipedia.org/wiki/Fractal" target="_blank" rel="noopener">分形</a>」这种东西，随便了解一下大概就能想到作者要用递归的方法来完成。所以这一篇教程性质的文章主要是讲在 Unity 里使用递归完成一些事情。鉴于大家应该上大学的时候随随便便上个课就差不多了解递归这种基本概念，因此我们就进展快一些～大概要完成以下事情：</p><ul><li>使用递归生成一大堆立方体和球体</li><li>整理一下使其变成分形</li><li>美化一下</li></ul><h2 id="PART-2-递归生成"><a href="#PART-2-递归生成" class="headerlink" title="PART 2 递归生成"></a>PART 2 递归生成</h2><p>首先我们要在 MonoBehaviour 里面生成一个立方体，需要如下代码。</p><pre><code class="lang-csharp">public class Fractal : MonoBehaviour{    public Mesh Mesh;    public Material Material;    // Use this for initialization    void Start ()    {        gameObject.AddComponent&lt;MeshFilter&gt;().mesh = Mesh;        gameObject.AddComponent&lt;MeshRenderer&gt;().material = Material;    }}</code></pre><p>非常简单，然后在场景里新建一个 GameObject 再挂上这个脚本，拖一些默认的 mesh 和 material 上去就好了，运行发现 OK 完美成功。那么说好的递归呢？非常简单，我们只需要在<code>Start()</code>里面创建一个新的 GameObject 再给他挂上这个 MonoBehaviour 就好。当然要记得限制递归的次数不然要爆炸～每次递归都记得调整子物体的位置和大小，最后设置一下递归深度这样就 OK 了，代码如下</p><pre><code class="lang-csharp">public class Fractal : MonoBehaviour{    public Mesh Mesh;    public Material Material;    public int Depth;    // Use this for initialization    void Start ()    {        gameObject.AddComponent&lt;MeshFilter&gt;().mesh = Mesh;        gameObject.AddComponent&lt;MeshRenderer&gt;().material = Material;        if (Depth &gt; 0)        {            new GameObject(&quot;Fractal Child&quot;).AddComponent&lt;Fractal&gt;().Initialize(this);        }    }    public void Initialize(Fractal parent)    {        Mesh = parent.Mesh;        Material = parent.Material;        Depth = parent.Depth - 1;        transform.SetParent(parent.transform);    }}</code></pre><p>那么这样就可以生成一大堆叠在一起的立方体了。。接下来的目标就是对这段代码修修补补让这些立方体组成看起来像是分形的样子。</p><h2 id="PART-3-分形"><a href="#PART-3-分形" class="headerlink" title="PART 3 分形"></a>PART 3 分形</h2><p>首先我们尝试让每个立方体在除了底面的每一面生成一个比他小一半的立方体。首先需要让<code>Initialize()</code>接收位置和方向以及大小的参数。</p><pre><code class="lang-csharp">public void Initialize(Fractal parent, float size, Vector3 pos, Vector3 rot){    Mesh = parent.Mesh;    Material = parent.Material;    Depth = parent.Depth - 1;    Size = size;    transform.SetParent(parent.transform);    transform.localPosition = pos;    transform.localEulerAngles = rot;    transform.localScale = Vector3.one * size;}</code></pre><p>非常简单，然后在每个立方体执行<code>Start()</code>的时候初始化 5 个小立方体，之所以我们需要设置小立方体的朝向是为了小立方体朝着其 Z 轴方向 (0, 0, 1) 生长，而不用考虑每次递归的时候的生长方向。代码如下</p><pre><code class="lang-csharp">private void Start (){    gameObject.AddComponent&lt;MeshFilter&gt;().mesh = Mesh;    gameObject.AddComponent&lt;MeshRenderer&gt;().material = Material;    if (Depth &lt;= 0) return;    var posOffset = Size + Size / 2f;    new GameObject(&quot;Fractal Child&quot;).AddComponent&lt;Fractal&gt;().Initialize(this, Size, Vector3.left * posOffset, new Vector3(0, -90, 0));    new GameObject(&quot;Fractal Child&quot;).AddComponent&lt;Fractal&gt;().Initialize(this, Size, Vector3.right * posOffset, new Vector3(0, 90, 0));    new GameObject(&quot;Fractal Child&quot;).AddComponent&lt;Fractal&gt;().Initialize(this, Size, Vector3.up * posOffset, new Vector3(-90, 0, 0));    new GameObject(&quot;Fractal Child&quot;).AddComponent&lt;Fractal&gt;().Initialize(this, Size, Vector3.down * posOffset, new Vector3(90, 0, 0));    new GameObject(&quot;Fractal Child&quot;).AddComponent&lt;Fractal&gt;().Initialize(this, Size, Vector3.forward * posOffset, new Vector3(0, 0, 0));}</code></pre><p>最后在场景里设置下<code>Scale = (0.5, 0.5, 0.5)</code>且<code>size = 0.5f Depth =  4</code>，再设置初始物体 Z 向上，即<code>(-90, 0, 0)</code>运行一下效果如图所示还不错～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018070701.png" alt="picture"></p><p>嗯感觉还不错～再多设置一下变成 6 呢？我的 Macbook Pro 风扇开始呼呼的转。。。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018070702.png" alt="picture"></p><p>接下来稍微重构下代码～之前的太丑了。我们把五行长得差不多的创建子物体的代码提取一下关键参数，完整版如下：</p><pre><code class="lang-csharp">public class Fractal : MonoBehaviour{    public Mesh Mesh;    public Material Material;    public int Depth;    public float Size;    private readonly Vector3[] _positions = {Vector3.left, Vector3.right, Vector3.up, Vector3.down, Vector3.forward};    private readonly Vector3[] _rotations = {Vector3.down, Vector3.up, Vector3.left, Vector3.right, Vector3.zero};    // Use this for initialization    private void Start ()    {        gameObject.AddComponent&lt;MeshFilter&gt;().mesh = Mesh;        gameObject.AddComponent&lt;MeshRenderer&gt;().material = Material;        if (Depth &lt;= 0) return;        var posOffset = Size + Size / 2f;        for (int i = 0; i &lt; 5; i++)        {            new GameObject(&quot;Fractal Child&quot;).AddComponent&lt;Fractal&gt;().Initialize(this, Size, _positions[i] * posOffset, _rotations[i] * 90);        }    }    public void Initialize(Fractal parent, float size, Vector3 pos, Vector3 rot)    {        Mesh = parent.Mesh;        Material = parent.Material;        Depth = parent.Depth - 1;        Size = size;        transform.SetParent(parent.transform);        transform.localPosition = pos;        transform.localEulerAngles = rot;        transform.localScale = Vector3.one * size;    }}</code></pre><h2 id="PART-4-美化"><a href="#PART-4-美化" class="headerlink" title="PART 4 美化"></a>PART 4 美化</h2><p>感觉作者写的美化一点都不美～不过我们还是按照教程顺手做一些换个 Mesh 啊随机旋转啦，生成机率之类的事情吧也算是有个交代。</p><h3 id="随机-Mesh"><a href="#随机-Mesh" class="headerlink" title="随机 Mesh"></a>随机 Mesh</h3><p>这个非常简单了我们把 Mesh 这个字段扩充成一个数组。然后在初始化<code>MeshFilter</code>的地方从里面随机一个出来，像下面这样。然后在拖一些 Mesh 进去。</p><pre><code class="lang-csharp">public class Fractal : MonoBehaviour{    public Mesh[] Mesh;    public Material Material;    ...    private void Start ()    {        gameObject.AddComponent&lt;MeshFilter&gt;().mesh = Mesh[Random.Range(0, Mesh.Length)];        gameObject.AddComponent&lt;MeshRenderer&gt;().material = Material;        ...    }    ...}</code></pre><p>这样就可以了～运行起来每次都不太一样。。图就不截了变化并不大大家应该可以想象出来～</p><h3 id="生成机率"><a href="#生成机率" class="headerlink" title="生成机率"></a>生成机率</h3><p>也很简单，添加一个机率然后在生成的地方每次随机一下，随到了就生成。。</p><pre><code class="lang-csharp">public class Fractal : MonoBehaviour{    ...    public float Probability;    ...    private void Start ()    {        ...        for (int i = 0; i &lt; 5; i++)        {            if (Random.Range(0, 1f) &lt;= Probability)            {                new GameObject(&quot;Fractal Child&quot;).AddComponent&lt;Fractal&gt;().Initialize(this, Size, _positions[i] * posOffset, _rotations[i] * 90);            }        }    }    public void Initialize(Fractal parent, float size, Vector3 pos, Vector3 rot)    {        ...        Probability = parent.Probability;        ...    }}</code></pre><p>把机率调成 0.75 以后生成效果如下图（跟上一条随机 Mesh 一起展示了）</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018070703.png" alt="picture"></p><h3 id="旋转起来吧"><a href="#旋转起来吧" class="headerlink" title="旋转起来吧"></a>旋转起来吧</h3><p>接下来要做的就是让这些东西全部动起来。。。并且以随机的速度。。嗯我已经可以想像出来大概是怎样的鬼畜场景了，尝试实现一下的话首先就是加一个最大旋转速度。然后在<code>Update()</code>里面随机好速度然后做一次旋转就好了～</p><pre><code class="lang-csharp">public class Fractal : MonoBehaviour{    ...    public float MaxRotateSpeed;    ...    private void Start ()    {        ...    }    private void Update()    {        var rotationSpeed = Random.Range(-MaxRotateSpeed, MaxRotateSpeed);        transform.Rotate(0f, rotationSpeed * Time.deltaTime, 0f);    }    ...}</code></pre><p>运行一下发现似乎总是在原地抖动的样子。。。一定是我们速度变换的频率太高了所以最终结果会趋近于原地不动，稍微限制一下加点随机。。</p><pre><code class="lang-csharp">public class Fractal : MonoBehaviour{    ...    public float MaxRotateSpeed;    public float RotateSpeedChangeRate;    private float RotateSpeed;    ...    private void Update()    {        Random.InitState(Depth * (int)Mathf.Ceil(Time.time * 100));        if (Random.Range(0, 1f) &lt;= RotateSpeedChangeRate)        {            RotateSpeed = Random.Range(-MaxRotateSpeed, MaxRotateSpeed);        }        transform.Rotate(0f, 0f,  RotateSpeed * Time.deltaTime);    }    public void Initialize(Fractal parent, float size, Vector3 pos, Vector3 rot)    {        ...        MaxRotateSpeed = parent.MaxRotateSpeed;        RotateSpeedChangeRate = parent.RotateSpeedChangeRate;        ...    }}</code></pre><p>哇画面真的是太诡异了。。。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018070705.gif" alt="animation"></p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>好的这一篇文章就这样成功的 <del>水过去了</del> 完成了～这一篇大概上就是递归的使用方法吧～其实没怎么看原文自己摸索的时候还是要稍微花几分钟的，不过还是非常简单啊大家随便看看应该就可以了解的很透彻了～感兴的同学的欢迎 follow 我的「<a href="https://github.com/sNaticY" target="_blank" rel="noopener">Github</a>」下载「<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">项目工程</a>」准备继续去玩 Screeps 喽~</p><hr><p>原文链接：<a href="https://snatix.com/2018/07/07/022-constructing-a-fractal/">https://snatix.com/2018/07/07/022-constructing-a-fractal/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      Catlike Coding, Unity制作分形, Unity基础教程, Unity中使用递归
    
    </summary>
    
      <category term="Catlike学习笔记" scheme="https://snatix.com/categories/Catlike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="教程" scheme="https://snatix.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="基础" scheme="https://snatix.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="csharp" scheme="https://snatix.com/tags/csharp/"/>
    
  </entry>
  
  <entry>
    <title>Catlike学习笔记(1.3)-使用Unity画更复杂的3D函数图像</title>
    <link href="https://snatix.com/2018/06/20/021-mathematical-surfaces/"/>
    <id>https://snatix.com/2018/06/20/021-mathematical-surfaces/</id>
    <published>2018-06-20T14:46:27.000Z</published>
    <updated>2020-01-16T01:51:21.822Z</updated>
    
    <content type="html"><![CDATA[<p>第三篇来了～今天去参加了 Unite 2018 Berlin，感觉就是。。。。非常困。。。回来以后稍微睡了下清醒了觉得是时候认真学习下了，不过讲的很多东西都是还没有发布或者只有 Preview 的版本，按照 Unity 的习惯肯定 Bug 多到令人发指，最近不太想折腾所以就先继续写文章把。。按照惯例奉上『<a href="https://catlikecoding.com/unity/tutorials/basics/mathematical-surfaces/" target="_blank" rel="noopener">原文链接</a>』</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>首先大概介绍一下什么是『<a href="https://catlikecoding.com/unity/tutorials/" target="_blank" rel="noopener">Catlike教程</a>』，大家自行访问一下就会发现是这位『<a href="https://www.patreon.com/catlikecoding/memberships" target="_blank" rel="noopener">大神</a>』写的一个 Unity 系列教程，里面由浅至深的以一个个有趣的小课题来引导大家学习 Unity 的方方面面～回想自己毕业三年都在做 Unity 游戏开发，然而看了大神的教程以后发现自己欠缺的东西非常多～真正对引擎的掌握程度非常低只是在不停的拼 UI 写业务逻辑。做这个系列呢也是希望自己可以坚持把大神的教程学完让自己变得更厉害～就酱。。</p><p>那么言归正传我们本期节目的最终目标是实现作者配图中的看起来很屌的图形，像是这样的。。。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018061201.jpg" alt="Animation"></p><p>对比上一篇文章的函数图像，大概有以下几个关键点需要实现。</p><ul><li>支持多函数叠加</li><li>从一条曲线变成一个曲面</li><li>由曲面扩展成真正的三维图形</li></ul><h2 id="PART-2-支持多函数叠加"><a href="#PART-2-支持多函数叠加" class="headerlink" title="PART 2 支持多函数叠加"></a>PART 2 支持多函数叠加</h2><p>首先我们的目标是可以通过一个滑杆来控制「<a href="https://snatix.com/2018/06/09/020-building-a-grap/">上一篇</a>」中的曲线显示的函数，因此先复制之前的代码改改名字比如 Graph3DController.cs 再修改类名与文件名一致。然后我们的关键是需要修改这一行</p><pre><code class="lang-csharp">var pos = new Vector3(x, Calc(x), 0);</code></pre><p>使其变成根据滑杆中的 int 值选择 delegate 中的某个函数，如下所示，代码中主要修改的地方用注释稍微解释了下。</p><pre><code class="lang-csharp">// 新的 deleagatepublic delegate float Function(float x, float t);// 记得修改类名与文件名一致否则不能挂在 gameobject 上public class Graph3DController : MonoBehaviour{    [Range(10, 100), SerializeField] private int _resolution;    [SerializeField] private GameObject _cube;    // 添加新的滑杆    [Range(0, 1), SerializeField] private int _function;    // 一个 delegate 数组用于保存我们接下来使用的两个函数    private Function[] _functions;    ...    // Use this for initialization    private void Start()    {        // 初始化 _functions         _functions = new Function[] {SineFunction, MultiSineFunction};                ...    }    private void Update()    {        _startX = -1f;        for (int i = 0; i &lt; _resolution; i++)        {            var x = _startX + i * _step;            // 此处修改调用方法            var pos = new Vector3(x, _functions[_function](x, Time.time), 0);            var point = _points[i];            point.transform.localPosition = pos;        }    }    private float SineFunction(float x, float t)    {        return Mathf.Sin(Mathf.PI * (x + t));    }    private float MultiSineFunction(float x, float t)    {        float y = Mathf.Sin(Mathf.PI * (x + t));        y += Mathf.Sin(2f * Mathf.PI * (x + 2f * t)) / 2f;        y *= 2f / 3f;        return y;    }}</code></pre><p>于是我们实现了如下的效果～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018061801.gif" alt="Animation"></p><p>不过作者在原文中还添加了 Enum 然后可以不用滑杆而是改用一个下拉菜单来改变要显示的函数图像。最终效果没什么不同就不再赘述了感兴趣的同学可以自行找到『<a href="https://catlikecoding.com/unity/tutorials/basics/mathematical-surfaces/" target="_blank" rel="noopener">原文链接</a>』查看更详细的步骤～</p><h2 id="PART-3-画出水滴的波纹"><a href="#PART-3-画出水滴的波纹" class="headerlink" title="PART 3 画出水滴的波纹"></a>PART 3 画出水滴的波纹</h2><p>那么接下来开始要真正的绘制一个3D曲面了~那么首先是创建更多的小方块～我们在初始化的地方改成一个二维的 List 来保存所有的小方块</p><pre><code class="lang-csharp">private void Start(){    ...    for (int i = 0; i &lt; _resolution; i++)    {        _points.Add(new List&lt;Transform&gt;());        for (int j = 0; j &lt; _resolution; j++)        {            var point = Instantiate(_cube, transform);            _points[i].Add(point.transform);            point.transform.localScale = scale;            point.SetActive(true);        }    }}</code></pre><p>在后续的遍历也对该二维数组进行遍历。</p><pre><code class="lang-csharp">private void Update(){    for (int i = 0; i &lt; _points.Count; i++)    {        for (int j = 0; j &lt; _points[i].Count; j++)        {            var posX = i * _step - 1;            var posZ = j * _step - 1;            var pos = new Vector3(posX, _functions[(int) _function](posX, posZ, Time.time), posZ);            var point = _points[i][j];            point.localPosition = pos;        }    }}</code></pre><p>最后再稍微修改下两个函数的参数就完成了从 2D 到 3D 的跳跃～如图所示</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018061802.gif" alt="Animation"></p><p>不过我们并不应该满足于此，感觉这样其实并没有充分利用 Z 轴啊，完全就是复制了很多条曲线排在一起。所以我们新建两个这样的函数。</p><pre><code class="lang-csharp">private float Sine2DFunction(float x, float z, float t){    float y = Mathf.Sin(Mathf.PI * (x + t));    y += Mathf.Sin(Mathf.PI * (z + t));    y *= 0.5f;    return y;}private float MultiSine2DFunction(float x, float z, float t){    float y = 4f * Mathf.Sin(Mathf.PI * (x + z + t * 0.5f));    y += Mathf.Sin(Mathf.PI * (x + t));    y += Mathf.Sin(2f * Mathf.PI * (z + 2f * t)) * 0.5f;    y *= 1f / 5.5f;    return y;}</code></pre><p>那么<code>Sine2DFunction</code>可以很明显的看出是两个完全一样的正弦波分别沿 x 轴和 Z 轴传播并且直接叠加，那么第二个。。。反正很复杂语言解释不清楚大概就是 3 个波叠加起来的，大家可以一行一行注释掉看看效果就知道了～</p><p>那么如何画出一个波纹呢，首先波纹是由原点也就是<code>(0, 0)</code>点开始均匀扩散的，那么可能是一个从原点向周围扩散的正弦波。那么直觉上来说这个函数可能长这样。。</p><pre><code class="lang-csharp">private float Ripple (float x, float z, float t) {    float d = Mathf.Sqrt(x * x + z * z);    float y = Mathf.Sin(Mathf.PI * (d - t));    return y;}</code></pre><p>运行下会发现完全不像，主要是因为水波在扩散的过程中是要衰减的，正弦波完全不会，因此我们需要加上衰减的控制。既然是衰减的话显然距离越大衰减的越多喽所以我们让 y 除以 <code>1 + 2 * Mathf.PI * d</code>试一试，之所以加1是为了防止在距离原点过于近的时候结果趋近于无穷大。所以现在代码变成了这样～</p><pre><code class="lang-csharp">private float Ripple(float x, float z, float t){    float d = Mathf.Sqrt(x * x + z * z);    float y = Mathf.Sin(Mathf.PI * (d - t));    y = y / (1 + 2 * Mathf.PI * d);    return y;}</code></pre><p>跑起来看一下会发现。。。emmmm</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018061901.png" alt="Animation"></p><p>所以我们再加上一些参数比如<code>_velocity</code>传播速度，<code>frequency</code>水波频率，<code>_amplitude</code>振幅，<code>_attenuation</code>衰减。代码如下。（这些参数并不是数值越大就直观意义上越大，虽然这样不太好但是懒得整理了。。。大家大概意思理解就好）</p><pre><code class="lang-csharp">private float Ripple(float x, float z, float t){    float d = Mathf.Sqrt(x * x + z * z);    float y = Mathf.Sin(_frequency * Mathf.PI * (d - t / _velocity));    y *= 1 / (_amplitude + _attenuation * 2 * Mathf.PI * d);    return y;}</code></pre><p>然后将这些参数调整到合适的值，就完成一个完美的水波了～如图所示</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018061902.gif" alt="Animation"></p><h2 id="PART-4-画出三维图形"><a href="#PART-4-画出三维图形" class="headerlink" title="PART 4 画出三维图形"></a>PART 4 画出三维图形</h2><p>显然我们不能满足于此，传入 x 和 z 来计算出唯一的 y 导致了无法有两个点拥有相同的 x 和 z，这极大的限制了我们的发挥～比如说画出一个球体之类的。所以我们接下来的目标是画出真正的三维图形～</p><p>在开始之前，我们首先要放弃传入 x 和 z 来计算 y 的设想，所以应该把所有的函数的返回值改成 Vector3，并且为了区分我们将函数的参数变成 u，v，t。</p><pre><code class="lang-csharp">public delegate Vector3 Function(float u, float v, float t);public enum GraphFunctionName {    Sine,    MultiSine,    Sine2D,    MultiSine2D,    Ripple,}public class Graph3DController : MonoBehaviour{    [Range(10, 100), SerializeField] private int _resolution;    [SerializeField] private GameObject _cube;    [SerializeField] public GraphFunctionName _function;    [SerializeField] private float _amplitude = 3;    [SerializeField] private float _frequency = 4;    [SerializeField] private float _velocity = 2;    [SerializeField] private float _attenuation = 6;    private List&lt;List&lt;Transform&gt;&gt; _points;    private float _step;    private Function[] _functions;    // Use this for initialization    private void Start()    {        _functions = new Function[] {SineFunction, MultiSineFunction, Sine2DFunction, MultiSine2DFunction, Ripple};        _cube.SetActive(false);        _points = new List&lt;List&lt;Transform&gt;&gt;();        _step = 2f / _resolution;        var scale = Vector3.one * _step;        for (int i = 0; i &lt; _resolution; i++)        {            _points.Add(new List&lt;Transform&gt;());            for (int j = 0; j &lt; _resolution; j++)            {                var point = Instantiate(_cube, transform);                _points[i].Add(point.transform);                point.transform.localScale = scale;                point.SetActive(true);            }        }    }    private void Update()    {        for (int i = 0; i &lt; _points.Count; i++)        {            for (int j = 0; j &lt; _points[i].Count; j++)            {                var u = i * _step - 1;                var v = j * _step - 1;                var point = _points[i][j];                point.localPosition = _functions[(int) _function](u, v, Time.time);            }        }    }    private Vector3 SineFunction(float u, float v, float t)    {        var x = u;        var y = Mathf.Sin(Mathf.PI * (u + t));        var z = v;        return new Vector3(x, y, z);    }    private Vector3 MultiSineFunction(float u, float v, float t)    {        var x = u;        float y = Mathf.Sin(Mathf.PI * (u + t));        y += Mathf.Sin(2f * Mathf.PI * (u + 2f * t)) / 2f;        y *= 2f / 3f;        var z = v;        return new Vector3(x, y, z);    }    private Vector3 Sine2DFunction(float u, float v, float t)    {        var x = u;        float y = Mathf.Sin(Mathf.PI * (u + t));        y += Mathf.Sin(Mathf.PI * (v + t));        y *= 0.5f;        var z = v;        return new Vector3(x, y, z);    }    private Vector3 MultiSine2DFunction(float u, float v, float t)    {        var x = u;        float y = 4f * Mathf.Sin(Mathf.PI * (u + v + t * 0.5f));        y += Mathf.Sin(Mathf.PI * (u + t));        y += Mathf.Sin(2f * Mathf.PI * (v + 2f * t)) * 0.5f;        y *= 1f / 5.5f;        var z = v;        return new Vector3(x, y, z);    }    private Vector3 Ripple(float u, float v, float t)    {        var x = u;        float d = Mathf.Sqrt(u * u + v * v);        float y = Mathf.Sin(_frequency * Mathf.PI * (d - t / _velocity));        y *= 1 / (_amplitude + _attenuation * 2 * Mathf.PI * d);        var z = v;        return new Vector3(x, y, z);    }}</code></pre><h3 id="圆柱体"><a href="#圆柱体" class="headerlink" title="圆柱体"></a>圆柱体</h3><p>那么如何组成一个圆柱体呢，首先我们知道圆柱体可以认为是由许多个圆环组成的，那么如何构成一个圆环呢？我们知道 u 的取值范围是[-1, 1]，将 u <em> PI 即可获得 [-PI, PI] 即刚好一个圆周的弧度，对应的坐标即是`(x = sin(PI </em> u), z = cos(PI * u))`，按照以上思路我们完成以下代码。然后每一个点的纵座标 y 就直接取 v 的值即可形成「每个水平的圆周上有100个点，共100个圆纵向排列组成的圆柱体」了好吧感觉表述的不是特别清楚写出来跑跑看就知道了。。。</p><pre><code class="lang-csharp">private Vector3 Cylinder(float u, float v, float t){    var x = Mathf.Sin(Mathf.PI * u);    var y = v;    var z = Mathf.Cos(Mathf.PI * u);    return new Vector3(x, y, z);}</code></pre><p>运行一下发现果然是一个圆柱体，如果想要控制圆柱体的半径和高直接在 x 和 z 乘以 R，y 乘以 H 即可，如下图所示。代码就不贴了大家都会自己乘～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018062001.png" alt="Animation"></p><p>那么如何让这个圆柱体动起来呢～比如说随便对 R 做一些手脚像下面这样</p><pre><code class="lang-csharp">private Vector3 InterestingCylinder(float u, float v, float t){    var r = _radius * (0.8f + Mathf.Sin(Mathf.PI * (6f * u + 2f * v + t)) * 0.2f);    var x = r * Mathf.Sin(Mathf.PI * u);    var y = _height * v;    var z = r * Mathf.Cos(Mathf.PI * u);    return new Vector3(x, y, z);}</code></pre><p>尝试改变 u 和 v 的系数可以看到很多有趣的现象哦～懒得自己写的可以打开我的「<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">Github Repo</a>」直接运行时修改 FactorU 和 FactorV 的值查看结果～最终我们可以达到类似这样的效果</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018062002.gif" alt="Animation"></p><h3 id="球体"><a href="#球体" class="headerlink" title="球体"></a>球体</h3><p>我们在圆柱体的基础上稍加修改就可以获得一个球体，首先，球体跟圆柱体一样也可以认为是很多半径不同的圆环组成的，那么圆环的半径呈现怎样的变化呢，我们想象球体沿经线切开后，可以观察到一圈纬线的半径和纬线的纵座标分别对应<code>Cos(PI / 2 * v)</code>和<code>Sin(PI / 2 * v)</code>，按照这个思路我们尝试写出如下代码。</p><pre><code class="lang-csharp">private Vector3 Sphere(float u, float v, float t){    var r = _radius * Mathf.Cos(Mathf.PI / 2 * v);    var x = r * Mathf.Sin(Mathf.PI * u);    var y = _radius * Mathf.Sin(Mathf.PI / 2 * v);    var z = r * Mathf.Cos(Mathf.PI * u);    return new Vector3(x, y, z);}</code></pre><p>运行一下发现完全没有问题～如图所示。。。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018062003.png" alt="Animation"></p><p>所以想要让球体动起来我们可以使用同样地思路对 r 的计算进行一点点魔改，比如说这样的一个参数<code>factor</code>：</p><pre><code class="lang-csharp">private Vector3 InterestingSphere(float u, float v, float t){    var factor = 0.8f + Mathf.Sin(Mathf.PI * (_factorU * u + t)) * 0.1f;    factor += Mathf.Sin(Mathf.PI * (_factorV * v + t)) * 0.1f;    var r = factor * _radius * Mathf.Cos(Mathf.PI / 2 * v);    ...}</code></pre><p>调一些奇怪的参数。。。然后就出现了一坨嚅动的，。。球体。。。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018062004.gif" alt="Animation"></p><h3 id="圆环体"><a href="#圆环体" class="headerlink" title="圆环体"></a>圆环体</h3><p>那么想象下一个圆环体和球体到底有什么区别呢，针对每左半条或者右半条经线圈，如果直接变成一个环，那么球体不就变成圆环了么。。。那么怎么变成圆环呢，我们之前提到</p><blockquote><p>一圈纬线的半径和纬线的纵座标分别对应<code>Cos(PI / 2 * v)</code>和`Sin(PI / 2 * v)</p></blockquote><p>所以我们把半个周期的 cos 和 sin 变成完整周期就可以了，不要除以 2 就好。。于是我们尝试着写下如下代码</p><pre><code class="lang-csharp">private Vector3 Torus(float u, float v, float t){    var r = _radius * Mathf.Cos(Mathf.PI * v);    var x = r * Mathf.Sin(Mathf.PI * u);    var y = _radius * Mathf.Sin(Mathf.PI * v);    var z = r * Mathf.Cos(Mathf.PI * u);    return new Vector3(x, y, z);}</code></pre><p>运行一下发现还是球体啊。。这是为什么呢，仔细观察发现似乎小方块比以前稀疏了，是因为半条经线被扩展到整个周期以后变成了一整圈经线，所以和对面的那半条完全重叠了。。所以怎么解决这个问题呢？就是扩大纬线圈让相对的两个半条经线不会相互重叠甚至完全分离就可以了。所以这样修改下试试</p><pre><code class="lang-csharp">private Vector3 Torus(float u, float v, float t){    var r = _radius * Mathf.Cos(Mathf.PI * v) + _radius2;    ...}</code></pre><p>这里之所以是加一个<code>_radius2</code>在最外面是为了达到「无论 v 如何变化都可以是的半径无条件增加 _radius2」的效果。。。运行下会发现嗯果然没问题了。。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018062005.png" alt="Animation"></p><p>所以最后也顺便让它动起来吧。。。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018062006.gif" alt="Animation"></p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>好吧这篇真的好长，而且写的好累并且在公式功能坏掉的情况下又很难讲清楚～大家把「<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">Github Repo</a>」下载下来自己运行稍微修改下就很容易理解了～总之我们把简单的图像扩展到了三维的图形的过程还是很有趣的～虽然不知道暂时有什么用处不过对于培养数学思维也还是挺有帮助的～好吧希望下一篇早日更新～就酱。。。</p><hr><p>原文链接：<a href="https://snatix.com/2018/06/20/021-mathematical-surfaces/">https://snatix.com/2018/06/20/021-mathematical-surfaces/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      Catlike Coding, Unity基础教程, Unity中使用Cube绘制3D图形
    
    </summary>
    
      <category term="Catlike学习笔记" scheme="https://snatix.com/categories/Catlike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="教程" scheme="https://snatix.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="基础" scheme="https://snatix.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="csharp" scheme="https://snatix.com/tags/csharp/"/>
    
  </entry>
  
  <entry>
    <title>Catlike学习笔记(1.2)-使用Unity画函数图像</title>
    <link href="https://snatix.com/2018/06/09/020-building-a-grap/"/>
    <id>https://snatix.com/2018/06/09/020-building-a-grap/</id>
    <published>2018-06-09T18:55:42.000Z</published>
    <updated>2020-01-16T01:51:21.821Z</updated>
    
    <content type="html"><![CDATA[<p>『<a href="https://catlikecoding.com/unity/tutorials/" target="_blank" rel="noopener">Catlike系列教程</a>』第二篇来了~今天周六，<del>早上</del>（上午11点）醒来去超市买了一周的零食回来以后就玩了一整天游戏非常有负罪感。现在晚上九点天还亮着感觉像下午7点左右的样子好像还不是很晚。。。所以就写一点东西吧。这一篇是「<a href="https://catlikecoding.com/unity/tutorials/basics/building-a-graph/" target="_blank" rel="noopener">Building a Graph</a>」挑战一下试试吧。</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>那么大概文章看下来我们预计要做以下事情。</p><ul><li>使用一定数量的小方块表达函数图像</li><li>做一个 Shader 给图像上色使其更好看</li><li>给图像传入时间参数使其动起来</li></ul><h2 id="PART-2-画函数图像"><a href="#PART-2-画函数图像" class="headerlink" title="PART 2 画函数图像"></a>PART 2 画函数图像</h2><p>首先我们确认一下要支持的功能细节，根据默认摄像机的位置和视野我们就暂定需要画出函数[-1. 1]之间的图像，同时可以通过一个条拖动来修改函数的解析度，假设解析度可以是[10,100]，那么我们需要在x=[-1, 1]之间生成[10,100]个方块。同时动态的调整方块的大小使其完美衔接。代码如下：</p><pre><code class="lang-csharp">public class GraphController : MonoBehaviour{    [Range(10, 100), SerializeField] private int _resolution;    [SerializeField] private GameObject _cube;    // Use this for initialization    private void Start ()    {        _cube.SetActive(false);        var step = 2f / _resolution;        var startPosX = -1f;        var scale = Vector3.one * step;        for (int i = 0; i &lt; _resolution; i++)        {            var pos = new Vector3(startPosX + i * step, Calc(startPosX + i * step), 0);            var point = Instantiate(_cube, transform);            point.transform.localPosition = pos;            point.transform.localScale = scale;            point.SetActive(true);        }    }    private float Calc(float x)    {        return Mathf.Pow(x, 2);    }}</code></pre><p>根据<code>Calc(float)</code>可以看出我们画出来曲线是如下函数的图像。 $y=x^2$ $f(x)=ax+b$</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018061001.png" alt="Graph"></p><h2 id="PART-3-给曲线上色"><a href="#PART-3-给曲线上色" class="headerlink" title="PART 3 给曲线上色"></a>PART 3 给曲线上色</h2><p>首先我们创建一个 Surface Shader，通过<code>Assets / Create / Standard Surface Shader</code>创建一个新的 Shader。修改代码如下：</p><pre><code class="lang-c">Shader &quot;Custom/ColoredPoint&quot; {    Properties {        _Glossiness (&quot;Smoothness&quot;, Range(0,1)) = 0.5        _Metallic (&quot;Metallic&quot;, Range(0,1)) = 0.0    }    SubShader {        Tags { &quot;RenderType&quot;=&quot;Opaque&quot; }        LOD 200        CGPROGRAM        // Physically based Standard lighting model, and enable shadows on all light types        #pragma surface surf Standard fullforwardshadows        // Use shader model 3.0 target, to get nicer looking lighting        #pragma target 3.0        // 此处将世界坐标传入IN        struct Input {            float3 worldPos;        };        half _Glossiness;        half _Metallic;        // Add instancing support for this shader. You need to check &#39;Enable Instancing&#39; on materials that use the shader.        // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.        // #pragma instancing_options assumeuniformscaling        UNITY_INSTANCING_BUFFER_START(Props)            // put more per-instance properties here        UNITY_INSTANCING_BUFFER_END(Props)        void surf (Input IN, inout SurfaceOutputStandard o) {            // 在这里根据世界坐标将方块染上不同的颜色            o.Albedo.rgb = IN.worldPos.xyz * 0.5 + 0.5;            // Metallic and smoothness come from slider variables            o.Metallic = _Metallic;            o.Smoothness = _Glossiness;            o.Alpha = 1;        }        ENDCG    }    FallBack &quot;Diffuse&quot;}</code></pre><p>运行效果如下~</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018061002.png" alt="Graph"></p><h2 id="PART-4-让曲线动起来"><a href="#PART-4-让曲线动起来" class="headerlink" title="PART 4 让曲线动起来"></a>PART 4 让曲线动起来</h2><p>首先曲线之所以会动当然是因为我们将时间作为参数同时传进去导致的~所以我们首先稍微改一下<code>Calc(float)</code>这个函数让时间参数也生效～这里用到<code>Mathf.PI</code>是为了图像从[-1, 1]之间完整的显示一个周期，大家可以随便改改试试。</p><pre><code class="lang-csharp">private float Calc(float x){    return Mathf.Sin(Mathf.PI * (x + Time.time));}</code></pre><p>然后直接运行肯定是不行的，我们需要把计算<code>y</code>和设置每个小方块的位置的代码移到<code>Update()</code>中去。最终代码如下：</p><pre><code class="lang-csharp">public class GraphController : MonoBehaviour{    [Range(10, 100), SerializeField] private int _resolution;    [SerializeField] private GameObject _cube;    private List&lt;Transform&gt; _points;    private float _step;    private float _startX;    // Use this for initialization    private void Start ()    {        _cube.SetActive(false);        _points = new List&lt;Transform&gt;();        _step = 2f / _resolution;        _startX = -1f;        var scale = Vector3.one * _step;        for (int i = 0; i &lt; _resolution; i++)        {            var point = Instantiate(_cube, transform);            _points.Add(point.transform);            point.transform.localScale = scale;            point.SetActive(true);        }    }    private void Update()    {        for (int i = 0; i &lt; _resolution; i++)        {            var x = _startX + i * _step;            var pos = new Vector3(x, Calc(x), 0);            var point = _points[i];            point.transform.localPosition = pos;        }    }    private float Calc(float x)    {        return Mathf.Sin(Mathf.PI * (x + Time.time));    }}</code></pre><p>运行效果如图：</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018061003.gif" alt="Animation"></p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>这一篇也很简单啊一边做一边写再随便划划水很快就完成了～最后大家可以下载「<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">Github Repo</a>」查看运行结果和全部代码~或者到「<a href="https://catlikecoding.com/unity/tutorials/basics/building-a-graph/" target="_blank" rel="noopener">原文地址</a>」查看更加详细的过程和思路。</p><hr><p>原文链接：<a href="https://snatix.com/2018/06/09/020-building-a-grap/">https://snatix.com/2018/06/09/020-building-a-grap/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      Catlike Coding, Unity使用Cube绘制函数图像, Unity基础教程
    
    </summary>
    
      <category term="Catlike学习笔记" scheme="https://snatix.com/categories/Catlike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="教程" scheme="https://snatix.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="基础" scheme="https://snatix.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="csharp" scheme="https://snatix.com/tags/csharp/"/>
    
  </entry>
  
  <entry>
    <title>Catlike学习笔记(1.1)-使用Unity实现一个钟表</title>
    <link href="https://snatix.com/2018/06/06/019-gameobject-and-scripts/"/>
    <id>https://snatix.com/2018/06/06/019-gameobject-and-scripts/</id>
    <published>2018-06-06T16:31:50.000Z</published>
    <updated>2020-01-16T01:51:21.824Z</updated>
    
    <content type="html"><![CDATA[<p>最近发现『<a href="https://catlikecoding.com/unity/tutorials/" target="_blank" rel="noopener">Catlike系列教程</a>』觉得内容真的很赞，感觉有很多地方涉及到了我的知识盲点，如果真的可以照着做下来一遍的话应该收获颇丰。因为教程很长所以逐字翻译不太可能了（主要是翻译的太差）。基本上就是把实现的思路记录下来最后甩一个 「<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">Github Repo</a>」这样就可以了。理论上来说第一篇比较简单，感兴趣的同学可以移步「<a href="https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/" target="_blank" rel="noopener">原文链接</a>」</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>实现一个钟表的话我们的目标就是</p><ul><li>用一个拍扁的圆柱体制作表盘，用立方体制作刻度和时针分针，用一个细长的圆柱体制作秒针</li><li>写点 c# 脚本使其显示为当前时间</li><li>加点动画让指针平滑运动</li></ul><h2 id="PART-2-制作场景"><a href="#PART-2-制作场景" class="headerlink" title="PART 2 制作场景"></a>PART 2 制作场景</h2><p>大家都是 Unity 熟手了所以具体制作流程就不讲了，博主自己也没仔细看就按照自己想法做了一个差不多的，具体思路就是多设一个层级然后父节点只旋转就可以把指针转到相应的位置而不需要同时调整 Rotation 和 Position。如果不是很懂的话可以回到「<a href="https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/" target="_blank" rel="noopener">原文地址</a>」里面有更详细的做法，或者到我的「<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">Github Repo</a>」下载下来看看。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018060801.png" alt="MakeScene"></p><h2 id="PART-3-写脚本控制指针"><a href="#PART-3-写脚本控制指针" class="headerlink" title="PART 3 写脚本控制指针"></a>PART 3 写脚本控制指针</h2><p>首先建立一个新的 MonoBehaviour 脚本比如说 ClockController.cs 之类的，把时针分针秒针的 Transform 的引用拖到脚本里，然后开始设置各个指针的位置。</p><p>那么众所周知表盘的360度被分割成12块所以每一块也就是每个小时占据了 360 / 12 = 30 度。同理每分钟占据了 360 / 60 = 6 度，每秒钟也是。那么直观来说就是这样写。</p><pre><code class="lang-csharp">void Update(){    _hourArm.localEulerAngles = new Vector3(0, DateTime.Now.Hour * 30, 0);    _minuteArm.localEulerAngles = new Vector3(0, DateTime.Now.Minute * 6, 0);    _secondArm.localEulerAngles = new Vector3(0, DateTime.Now.Second * 6, 0);}</code></pre><p>然而运行一下会发现时针和分针都是笔直的指向其所在的时间。。如下图所示</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018060802.png" alt="Clock"></p><p>好吧现在刚好七点钟貌似看不出来，总之就是需要在比如 6:30 的时候时针应该指向 6 和 7 之间。所以这个度数需要再加上一点偏移，变成下面这样。</p><pre><code class="lang-csharp">void Update(){    var hour = DateTime.Now.Hour;    var minute = DateTime.Now.Minute;    var second = DateTime.Now.Second;    var milisecond = DateTime.Now.Millisecond;    _hourArm.localEulerAngles = new Vector3(0, hour * 30 + minute  / 60f * 30f, 0);    _minuteArm.localEulerAngles = new Vector3(0, minute * 6 + second / 60f * 6f, 0);    _secondArm.localEulerAngles = new Vector3(0, second * 6 + milisecond / 1000f * 6f, 0);}</code></pre><p>就可以轻松实现文章里的各种平滑移动之类的～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2018060803.gif" alt="Animation"></p><h2 id="PART-4-总结"><a href="#PART-4-总结" class="headerlink" title="PART 4 总结"></a>PART 4 总结</h2><p>没有完全按照「<a href="https://catlikecoding.com/unity/tutorials/basics/game-objects-and-scripts/" target="_blank" rel="noopener">原文</a>」中的写法来写好像这样会更简洁一点，然后大家应该也会更容易理解，不过作者的主要用意可能是想展示 coroutine 之类的吧不管那些了～总之大家可以进入「<a href="https://github.com/sNaticY/CatlikePractice" target="_blank" rel="noopener">Github Repo</a>」查看全部代码和运行 Demo。</p><hr><p>原文链接：<a href="https://snatix.com/2018/06/06/019-gameobject-and-scripts//">https://snatix.com/2018/06/06/019-gameobject-and-scripts//</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      Catlike Coding, Unity制作钟表, Unity基础教程, Unity基础GameObject使用
    
    </summary>
    
      <category term="Catlike学习笔记" scheme="https://snatix.com/categories/Catlike%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="教程" scheme="https://snatix.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="基础" scheme="https://snatix.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="csharp" scheme="https://snatix.com/tags/csharp/"/>
    
  </entry>
  
  <entry>
    <title>快节奏多人游戏同步(4)-延时补偿</title>
    <link href="https://snatix.com/2018/05/30/018-lag-compensation/"/>
    <id>https://snatix.com/2018/05/30/018-lag-compensation/</id>
    <published>2018-05-30T15:22:00.000Z</published>
    <updated>2018-07-25T16:47:02.673Z</updated>
    
    <content type="html"><![CDATA[<p>持续一个月的坑终于要填完了～全系列最后一篇贴出「<a href="http://www.gabrielgambetta.com/lag-compensation.html" target="_blank" rel="noopener">原文地址</a>」还有最后的「<a href="http://www.gabrielgambetta.com/client-side-prediction-live-demo.html" target="_blank" rel="noopener">演示 Demo</a>」，翻译的好累而且又不太能翻译到很通畅还能附带些许个人风格，感觉好难～下次还是自己原创一些文章比较好。最近几天打包打到晚上11点下班好累，希望有空可以真的把自动化打包的坑继续填起来。。。</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>之前三篇文章主要解释了关于 client-server 游戏架构，总结起来大概就是以下这些：</p><ul><li>服务器从所有的客户端获取带着时间戳的输入</li><li>服务器负责处理所有输入并更新游戏世界的状态</li><li>服务器向所有客户端发送游戏世界的快照</li><li>客户端发送输入并自己模拟该输入造成的结果</li><li>客户端获取世界更新<ul><li>将客户端自行预测的状态更新到与服务器一致的状态</li><li>将其他客户端控制的实体插值到过去的状态</li></ul></li></ul><p>从玩家的角度来看，以上行为会导致两个重要的结果：</p><ul><li>玩家看到 <strong>自己</strong> 处于 <strong>现在</strong></li><li>玩家看到 <strong>其他玩家</strong> 处于 <strong>过去</strong></li></ul><p>通常来说这种情况并没有什么问题，但是在时间或空间敏感的状况下不太适合，比如说爆头之类的</p><h2 id="PART-2-延时补偿"><a href="#PART-2-延时补偿" class="headerlink" title="PART 2 延时补偿"></a>PART 2 延时补偿</h2><p>假设你正用狙击枪完美的瞄准目标的头部，此时射击绝对万无一失。</p><p>然而却没打到。。。</p><p>为什么会发生这种事情。。</p><p>因为我们之前解释过的 client-server 架构，你瞄准的是 100ms 之前的玩家的头，而不是开枪的时候的玩家的头。。。</p><p>在某种程度上相当于你在一个光速非常非常慢的宇宙中进行游戏，你瞄准的是敌人过去的位置，当你扣下扳机的时候他早就走远了。。</p><p>幸运的是，有一个相当简单的方案可以让大多数玩家在大多数情况下满意（下面会解释）</p><p>方法如下：</p><ul><li>开火的时候，客户端发送开火指令到服务器，同时包含开火的一瞬间确切的时间和方向。</li><li><strong>至关重要的一步</strong>，服务器获取到所有带有时间戳的输入后，服务器可以重新构建过去任何时刻的游戏状态。尤其是可以精确的重建任何客户端在任何时间点看到的游戏状态</li><li>这意味着服务器可以确切的知道在你射击的一刹那你的枪瞄准的到底是什么，虽然那是你的目标的过去的位置，但是服务器知道你瞄准的就是你的目标在你自己的「当前时间」所在的位置</li><li>服务器处理「该时间点」的射击行为并更新每个客户端</li></ul><p>于是皆大欢喜～</p><p>服务器很开心是因为他是服务器，他永远都很开心。。。哦好冷啊</p><p>你很开心是因为你瞄准目标头部并射击，完成了一记漂亮的爆头</p><p>你的敌人可能是唯一不完全开心的哪个，如果他站在原地被你爆头那就是他的问题，但是如果他在移动的话，只能说明你是特别厉害的狙击手。</p><p>但是如果他在掩体附近，然后移动到掩体内部的安全位置后才被命中了呢？</p><p>好吧这的确有可能发生，但这就是你要为此付出的代价，因为你可以射击「过去的他」，他可能在进入掩体后几毫秒被射击。</p><p>从某种程度上来说这是不公平的，但这是大家接受程度最高的解决方案了，明明瞄准开枪最后却 miss 问题更大～</p><h2 id="PART-3-总结"><a href="#PART-3-总结" class="headerlink" title="PART 3 总结"></a>PART 3 总结</h2><p>这篇文章是快节奏多人游戏同步这个系列的最后一篇了，虽然这类问题很难得到完美解答，但是对相关概念有了清晰理解以后再看也并不是那么困难。</p><p>虽然本文的读者都是游戏开发者，但依然有着另一部分读者对此很感兴趣，那就是玩家们。对玩家来说去理解诸如此类问题依然是一件很有趣的事情。</p><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p>以下是一些参考资料包括文章和源码之类的，可以帮助大家更方便的理解相关概念。</p><p>与本文相关性最高的文章如下 <a href="http://gafferongames.com/networking-for-game-programmers/what-every-programmer-needs-to-know-about-game-networking/" target="_blank" rel="noopener">What Every Programmer Needs to Know About Game Networking</a>  <a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization" target="_blank" rel="noopener">Latency Compensating Methods in Client/Server In-game Protocol Design and Optimization</a>.</p><hr><p>原文链接：<a href="https://snatix.com/2018/05/30/018-lag-compensation/">https://snatix.com/2018/05/30/018-lag-compensation/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续一个月的坑终于要填完了～全系列最后一篇贴出「&lt;a href=&quot;http://www.gabrielgambetta.com/lag-compensation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;」还有最后的「&lt;a href=&quot;http://www.gabrielgambetta.com/client-side-prediction-live-demo.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;演示 Demo&lt;/a&gt;」，翻译的好累而且又不太能翻译到很通畅还能附带些许个人风格，感觉好难～下次还是自己原创一些文章比较好。最近几天打包打到晚上11点下班好累，希望有空可以真的把自动化打包的坑继续填起来。。。&lt;/p&gt;
    
    </summary>
    
      <category term="快节奏多人游戏同步" scheme="https://snatix.com/categories/%E5%BF%AB%E8%8A%82%E5%A5%8F%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%90%8C%E6%AD%A5/"/>
    
    
      <category term="多人游戏" scheme="https://snatix.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="同步" scheme="https://snatix.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="客户端" scheme="https://snatix.com/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
      <category term="服务器" scheme="https://snatix.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>快节奏多人游戏同步(3)-Entity插值</title>
    <link href="https://snatix.com/2018/05/18/017-entity-interpolation/"/>
    <id>https://snatix.com/2018/05/18/017-entity-interpolation/</id>
    <published>2018-05-18T12:40:00.000Z</published>
    <updated>2018-07-25T16:09:02.130Z</updated>
    
    <content type="html"><![CDATA[<p>第三篇也新鲜出炉了～之前随便找了下发现其实这个系列已经有人翻译过了，翻译的也还可以但是坑已经开始挖了最好就顺便填完吧反正也没有很深。不管怎么说也是认认真真的重新翻译了一遍希望相比其他的翻译可以更上一层楼，虽然有些名词感觉不管怎么翻译都怪怪的干脆就保留原文说不定更容易理解一点。最后依然贴出「<a href="http://www.gabrielgambetta.com/entity-interpolation.html" target="_blank" rel="noopener">原文地址</a>」大家不放心或者不太理解的地方直接查看原文就好。</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>在本系列的「<a href="http://snatix.com/2018/05/07/015-client-server-game-architecture/">第一篇文章</a>」中，我们介绍了关于权威服务器及其反作弊特性，然而仅仅是最简单的实现可能会导致关于可玩性和响应速度的问题。在「<a href="http://snatix.com/2018/05/14/016-client-side-prediction-and-server-reconciliation/">第二篇文章</a>」中，我们提出了「客户端预测」的方案来克服这个困难。</p><p>以上两篇文章事实上介绍的是一种在连接到有传输延迟的远程权威服务器的状况下，可以让玩家像单机游戏一样流畅的控制角色移动的一种概念和技术。</p><p>在本文中，我们将会讨论在在同一台服务器上有「其他玩家控制的角色」的情况。</p><h2 id="PART-2-服务器-time-step"><a href="#PART-2-服务器-time-step" class="headerlink" title="PART 2 服务器 time step"></a>PART 2 服务器 time step</h2><p>在之前的文章中，我们的服务器的实现非常简单，它负责处理客户端的输入并更新游戏状态，最后将结果发送回客户端。但是当多个玩家连接的时候，服务器主循环会有略微不同。</p><p>在多个客户端连接到同一台服务器的情况下，每个客户端可能会以相当快的频率发送输入（取决于玩家发送指令的频率，比如按下按键，移动鼠标或者点击屏幕之类的）每次收到客户端输入就更新游戏状态并广播给全部玩家可能会消耗过多的 cpu 资源和带宽。</p><p>更好的方案是将客户端的输入放进队列中先不处理，等待服务器周期性的更新，例如每秒钟10次之类的。这100ms 我们便称之为服务器的 time step。每次更新都会将所有未被处理的输入进行处理，最后将新的游戏状态广播给所有玩家。</p><p>总而言之，整个游戏会以固定的，不受客户端输入的指令内容和数量影响的频率持续更新。</p><h2 id="PART-3-低频更新处理"><a href="#PART-3-低频更新处理" class="headerlink" title="PART 3 低频更新处理"></a>PART 3 低频更新处理</h2><p>从客户端的角度来看，这种方法像以前一样可用，因为客户端预测独立于延迟更新之外，所以很明显在相对低频的状态更新下仍然有效。然而由于游戏状态以较低频率广播（例如100ms），客户端只能得到较少的其他正在移动的实体的信息。</p><p>原本的实现将会在收到其他角色的位置信息时立即更新其状态，这将会导致角色每 100ms 顺移一次而非平滑移动。</p><p><img src="https://s2.51cto.com/wyfs02/M02/8D/AE/wKiom1ilt5DD1uwkAACfpevkX3A342.png-wh_500x0-wm_3-wmp_4-s_4138866562.png" alt="Client 1 as seen by Client 2."></p><p>根据你所开发的游戏类型的不同，这个问题有很多不同的解决方案，你的游戏中的实体可预测性越高，你就越容易得出正确的结果。</p><h2 id="PART-4-航位推测法"><a href="#PART-4-航位推测法" class="headerlink" title="PART 4 航位推测法"></a>PART 4 航位推测法</h2><p>假设你正在制作一个赛车游戏，一辆跑得非常快的车是很容易预测的，比如说辆车的速度是 100m/s ，一秒后这辆车的位置大概就是其前方100m处。</p><p>为什么是『大概』呢？因为在这一秒钟之间这两车可能加速或者减速了一点点，或者左拐右拐了的一点点，这里的关键词是『一点点』。无论玩家做了什么操作，高速行驶的车辆的机动性很大程度上取决于它之前的位置，方向和速度。换而言之，一辆车不能瞬间180度大转弯～</p><p>为什么这种方法适用于每 100ms 发送一次消息的服务器呢？客户端收到每一个对手车辆的已被验证过的速度和方向后，接下来的100ms之内并不会收到其他任何消息，但是客户端仍然需要将移动的过程显示出来，最简单的方式就是假设车辆的速度和航向在这100ms内保持不变，然后在本地移动车辆的物理位置。然后在100ms后，服务器返回消息时再矫正车辆的位置。</p><p>这里的「矫正」可能很大也可能很小，取决于许多变量。如果玩家直直的开着车完全没有拐弯也没有踩刹车和油门，那么预测的位置将会与最终位置完全匹配。然而玩家撞到什么东西的话，预测出来的位置将会产生巨大的误差。</p><p>需要注意的是，航位推测法可以适用于低速情形，比如战列舰等。事实上「航位推测法」这个词本来就来自于海军导航术语。</p><h2 id="PART-5-实体插值"><a href="#PART-5-实体插值" class="headerlink" title="PART 5 实体插值"></a>PART 5 实体插值</h2><p>有一些情形「航标推测法」是无法适用的，尤其是那些玩家的方向和速度会突然变化的那种。。比如说在3d射击游戏中，玩家经常会很以极快的速度走走停停转方向，由于位置和速度不再是可预测的，使得航标推测法完全没用了。</p><p>在服务器下发数据的时候才更新位置是不行的，因为这样会导致玩家每100ms闪现一次，严重影响正常游戏～</p><p>目前的状况是客户端只知道每 100ms 的玩家的准确位置，因此关键在于如何在两个 100ms 之间把发生的事情「脑补」出来。解决这个问题只需要将其他玩家相对于玩家自己的“过去”的位置显示出来就好了。</p><p>假设你在 <strong>t = 1000</strong> 收到了所有玩家的位置信息，因为 <strong>t = 900</strong> 时的游戏状态也已经收到了，所以你同时知道某个玩家 <strong>t = 900</strong> 和 <strong>t = 1000</strong> 时的位置，所以从 <strong>t = 1000</strong> 到 <strong>t = 1100</strong> ，你可以显示其他玩家 <strong>t = 900</strong> 到 <strong>t = 1000</strong> 这段时间内做的事情。如此你便一直显示着你自己的确切位置，而其他玩家则晚 100ms 才更新。</p><p><img src="http://www.gabrielgambetta.com/img/fpm3-02.png" alt="Client 2 renders Client 1 in the past, interpolating last known positions."></p><p>用来从 <strong>t = 900</strong> 到 <strong>t = 1000</strong> 插值的位置信息取决于游戏本身，一般来说插值法表现还不错。如果不满意的话，可以让服务器发送更多的细节给你，比如说发送玩家在移动过程中的片段序列，或者每10ms进行一次采样从而让插值结果更加自然。（发送的数据量并不一定是原来的10倍，尝试改成发送增量式的位置可以在特定情况下可以得到极大的优化）</p><p>需要注意的是使用这种技术，每个玩家看到的游戏世界可能会有略微不同。因为每个玩家都看到自己当前状态但是看到的是其他玩家的过去状态。即使是快节奏游戏中也是如此。不过一般来说100ms的延迟不是非常明显。</p><p>有一种例外，当你需要很精确的计算的时候，比如说一个玩家开枪射击另一个玩家，因为你看到的是其他玩家是过去的位置，导致你的瞄准总是延迟了 100ms ，这就意味着你瞄准的总是目标100ms之前的位置，我们在下一篇文章中会处理这个问题。</p><h2 id="PART-6-总结"><a href="#PART-6-总结" class="headerlink" title="PART 6 总结"></a>PART 6 总结</h2><p>即便是低频更新和网络延迟的情况下，你也必须让玩家感受到持续的平滑移动。在「<a href="http://snatix.com/2018/05/14/016-client-side-prediction-and-server-reconciliation/">第二篇文章</a>」中，我们讲解了客户端预测和服务器调和方法来让玩家实时移动以确保玩家的输入会得到立即反馈，从而避免的延迟造成的不适感。</p><p>但是其他的玩家控制的实体依然有问题，在本文中我们介绍了两种方法来解决。</p><p>第一种是 「航位推测法」 在特定种类的模拟游戏中实体的位置可以根据当前的速度和加速度等等进行预测。但是在条件不符合的时候就会导致预测失败。</p><p>第二种 「实体插值法」 完全不预测未来的位置，只使用实体的真实数据然后将其显示的时间略微延迟。</p><p>这种方法唯一的影响就是玩家同时看到了自己「<em>现在的</em>状态」和其他人「<em>过去的状态</em>」，这通常可以带来天衣无缝的体验。</p><p>然而仅仅是这样的话，当某个事件需要被极其精确的处理的时候就会出现问题，比如说当你射击移动物体时，「客户端2」屏幕上显示的「客户端1」的位置既不是服务器中「客户端1」的位置也不是「客户端1」自己显示的位置。所以爆头什么的变成了不可能的任务，然而类似设定在各种游戏中都必不可少，因此我们会在下一篇文章中解决这个问题。</p><hr><p>原文链接：<a href="https://snatix.com/2018/05/18/017-entity-interpolation/">https://snatix.com/2018/05/18/017-entity-interpolation/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第三篇也新鲜出炉了～之前随便找了下发现其实这个系列已经有人翻译过了，翻译的也还可以但是坑已经开始挖了最好就顺便填完吧反正也没有很深。不管怎么说也是认认真真的重新翻译了一遍希望相比其他的翻译可以更上一层楼，虽然有些名词感觉不管怎么翻译都怪怪的干脆就保留原文说不定更容易理解一点。最后依然贴出「&lt;a href=&quot;http://www.gabrielgambetta.com/entity-interpolation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;」大家不放心或者不太理解的地方直接查看原文就好。&lt;/p&gt;
    
    </summary>
    
      <category term="快节奏多人游戏同步" scheme="https://snatix.com/categories/%E5%BF%AB%E8%8A%82%E5%A5%8F%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%90%8C%E6%AD%A5/"/>
    
    
      <category term="多人游戏" scheme="https://snatix.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="同步" scheme="https://snatix.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="客户端" scheme="https://snatix.com/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
      <category term="服务器" scheme="https://snatix.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>快节奏多人游戏同步(2)-客户端预测与服务器调和</title>
    <link href="https://snatix.com/2018/05/14/016-client-side-prediction-and-server-reconciliation/"/>
    <id>https://snatix.com/2018/05/14/016-client-side-prediction-and-server-reconciliation/</id>
    <published>2018-05-14T16:11:11.000Z</published>
    <updated>2018-07-25T16:09:02.130Z</updated>
    
    <content type="html"><![CDATA[<p>第二篇终于翻译结束了，发现直接在 github 网页上修改草稿还是挺方便的，抽空就可以随时翻译一下，最后再整理发布。关于这一篇没有太多好说的基本上就是稍微有一点点干货，翻译的不好希望大家见谅，同样贴出「<a href="http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html" target="_blank" rel="noopener">原文地址</a>」，不是很清晰的地方大家可以对照着看一下。</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>在本系列的<a href="http://snatix.com/2018/05/07/015-client-server-game-architecture/">第一篇文章</a>中，我们简单的讨论了『权威服务器和傀儡客户端模型』，即客户端发送输入到服务器，由服务器更新游戏状态后返回给客户端，最后再由客户端渲染的流程。</p><p>这样简单的流程可能会导致从用户输入到最终屏幕显示之间的延迟，例如玩家按下向右按键后半秒角色才开始移动，这是因为客户端的输入必须先发送到服务器，由服务器计算游戏状态并将结果发回客户端而导致的延迟。</p><p><img src="http://www.gabrielgambetta.com/img/fpm2-01.png" alt="Effect of network delays."></p><p>在非局域网环境下，延迟可能达到1/10秒，可能会导致游戏响应不够灵敏，最坏的情况可能导致基本玩不了。。在本文中，我们将尽可能的最小化这个问题带来的影响，直至彻底解决的方案。</p><h2 id="PART-2-客户端预测"><a href="#PART-2-客户端预测" class="headerlink" title="PART 2 客户端预测"></a>PART 2 客户端预测</h2><p>纵使有一些作弊的玩家，但大多数情况下服务器都是在处理有效请求（包括非作弊玩家的请求和某些未在特定情况下作弊的客户端的请求）这意味着大多数输入将会是有效的且游戏状态是完全可预测的。也就是说，如果你的角色在(10,10)位置，当按下向右按键时，该角色一定会移动到(11,10)。</p><p>如果游戏世界可预测性足够强（也就是说，一个给定的游戏状态加上一组输入，将可以得到固定的结果）的话，我们可以尝试利用这个特性。</p><p>首先假设我们的延迟是100ms，并且由一个格子移动到下一个格子的动画需要播放100ms，那么在最原始的实现中，整个角色的动作将延迟200ms</p><p>因为游戏世界时可预测的，因此我们可以认为发到服务器的指令将会被立即成功执行，在这种情况下，客户端就可以预测输入执行以后的游戏状态了，而且大多数情况下这个预测都是基本正确的。</p><p><img src="http://www.gabrielgambetta.com/img/fpm2-02.png" alt="Network delay + animation."></p><p>因此我们可以发送输入后在等待服务器返回的同时立刻渲染输入执行成功后的结果，而不是傻等着服务器返回结果后再进行渲染。这样大多数情况下客户端自行计算的结果基本上是与服务器的返回相匹配的。</p><p><img src="http://www.gabrielgambetta.com/img/fpm2-03.png" alt="Animation plays while the server confirms the action."></p><p>所以现在在玩家输入与屏幕渲染之间完全没有延迟了，而且游戏服务器依然是权威服务器。因为当被破解的客户端发送无效请求时虽然会在自己的屏幕上显示出来，但并不会影响到其他玩家。</p><h2 id="PART-3-同步问题"><a href="#PART-3-同步问题" class="headerlink" title="PART 3 同步问题"></a>PART 3 同步问题</h2><p>在上面的例子中，我们刚好选了一个可以让一切正常运行的数值，那么接下来我们考虑一下以下场景，客户端到服务器的延迟是250ms，但是从一个格子移动到另一个格子只需要100ms，并且玩家尝试两次按下向右按键来向右移动两格。</p><p>按照目前的实现，我们将看到如下状况。</p><p><img src="http://www.gabrielgambetta.com/img/fpm2-04.png" alt="Predicted state and authoritative state mismatch."></p><p>于是我们在 <strong>t = 250 ms</strong> 的时候就会面临一个非常 interesting 的问题，当接收到新的游戏状态时，客户端预测的位置已经到达 <strong>x = 12</strong>，但是服务器认为最新的坐标是 <strong>x = 11</strong>，因为权威服务器的缘故，客户端必须将角色移回 <strong>x = 11</strong>，但是紧接着，新的 <strong>x = 12</strong> 的状态在 <strong>t = 350</strong> 的时间到达，因此角色的位置又顺移回去了。。</p><p>从玩家的角度来看，他按下两次向右按钮后，角色向右移动两格，原地停留50ms后，向左顺移一格，又原地停留100ms再向右顺移一格，很明显这种情况令人难以接受。</p><h2 id="PART-4-服务器调和"><a href="#PART-4-服务器调和" class="headerlink" title="PART 4 服务器调和"></a>PART 4 服务器调和</h2><p>问题的关键在于，客户端显示的是「<em>当前时间</em>」的游戏状态，但是因为延迟的关系，收到来自服务器的回复是「<em>过去</em>」的游戏状态。因为在收到服务器回包的时间点服务器还没有处理完客户端在该时间点之前发送的全部输入。</p><p>这并不是一个非常严重的问题，首先，客户端在每次请求的时候加上一个编号，在我们的例子中，第一次按键请求编号为 #1，第二次按键的请求编号为 #2。服务器回复的时候将其处理过最后一个请求的编号包含在消息中。</p><p><img src="http://www.gabrielgambetta.com/img/fpm2-05.png" alt="Client-side prediction + server reconciliation."></p><p>那么现在，在 <strong>t = 250</strong> 的时候，服务器回复说 “<strong>基于#1号请求的结果，你的坐标是x=11</strong>”，因为权威服务器的关系，角色坐标将会被设置为<strong>x = 11</strong>。如果客户端将每一个发送至服务器的指令都保存下来的话，当收到了服务器的回包，客户端就知道服务器已经执行了 #1 号请求，所以就可以将保存下来的#1号请求的备份删除掉了，并且客户端还知道服务器目前尚未处理#2号请求的更新结果，因此客户端就可以基于服务器已经认证过的请求#1的结果结合服务器尚未处理的请求#2来重新预测客户端的当前状态。</p><p>所以在 <strong>t = 250</strong> 的时候，客户端收到 “<strong>x = 11, 上次处理的请求 = #1</strong>”。于是客户端丢弃了#1号请求的备份，因为服务器尚未处理#2号请求，因此客户端依然保留#2号请求的备份。于是客户端将会基于服务器发送的 <strong>x = 11</strong> 来更新其内部游戏状态，然后将服务器尚未接收到的请求进行模拟计算。于是 #2号请求“向右移动”将会得到正确的结果，<strong>x = 12</strong>。</p><p>继续我们的例子，在 <strong>t = 350</strong> 的时候，从服务器收到了新的游戏状态 “<strong>x = 12, 上次处理的请求 = #2</strong>”。于是客户端丢弃了#2号请求前的所有备份，并将游戏状态更新到了<strong>x = 12</strong>。目前已经没有尚未被处理的请求了，进程结束在了正确的状态。</p><h2 id="PART-5-误差"><a href="#PART-5-误差" class="headerlink" title="PART 5 误差"></a>PART 5 误差</h2><p>虽然以上的例子只讨论了移动的情况，但是同样地规则几乎可以适用于任何状况，例如在回合制对抗游戏中，当玩家攻击其他的角色时，可以先把最新的血条「显示」出来就好像已经完成攻击了一样，但是直到服务器回复之前最好不要真正的更新角色的血量。</p><p>因为游戏状态非常复杂，因此很多时候并不能轻易的逆转。就算是客户端状态认为某个角色的血量掉到0，你也要尽可能避免在收到服务器的确认之前就杀死该角色。（如果其他角色在你致死攻击前使用了急救包而服务器并没有告诉你呢？）</p><p>于是一个有趣的结论诞生了，即使整个游戏世界是完全可预测的而且没有任何客户端作弊，在服务器调和后依然无法保证客户端预测的游戏状态与服务器下发的真实状态完全匹配。虽然在只有单个玩家的情况下这种情景不可能发生，但在多个玩家同时连接到服务器的情况下很容易发生。我们将在下一篇文章中讨论这个问题。</p><h2 id="PART-6-总结"><a href="#PART-6-总结" class="headerlink" title="PART 6 总结"></a>PART 6 总结</h2><p>当我们使用权威服务器时，即使是在等待服务器处理你的输入也要尽可能让玩家感到反应迅速。要做到这一点，需要客户端提前将其发送到服务器的输入进行模拟并显示结果。当客户端收到服务器的状态更新时，客户端再重新根据服务器发来的新状态来计算后续输入的运行结果。</p><hr><p>原文链接：<a href="https://snatix.com/2018/05/14/016-client-side-prediction-and-server-reconciliation/">https://snatix.com/2018/05/14/016-client-side-prediction-and-server-reconciliation/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第二篇终于翻译结束了，发现直接在 github 网页上修改草稿还是挺方便的，抽空就可以随时翻译一下，最后再整理发布。关于这一篇没有太多好说的基本上就是稍微有一点点干货，翻译的不好希望大家见谅，同样贴出「&lt;a href=&quot;http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;」，不是很清晰的地方大家可以对照着看一下。&lt;/p&gt;
    
    </summary>
    
      <category term="快节奏多人游戏同步" scheme="https://snatix.com/categories/%E5%BF%AB%E8%8A%82%E5%A5%8F%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%90%8C%E6%AD%A5/"/>
    
    
      <category term="多人游戏" scheme="https://snatix.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="同步" scheme="https://snatix.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="客户端" scheme="https://snatix.com/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
      <category term="服务器" scheme="https://snatix.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>快节奏多人游戏同步(1)-ClientServer架构</title>
    <link href="https://snatix.com/2018/05/07/015-client-server-game-architecture/"/>
    <id>https://snatix.com/2018/05/07/015-client-server-game-architecture/</id>
    <published>2018-05-07T15:31:49.000Z</published>
    <updated>2018-07-25T16:09:02.130Z</updated>
    
    <content type="html"><![CDATA[<p>嗯。。。所以就翻译一下「快节奏多人游戏同步」这个系列吧～自从来柏林似乎就一直没有写文章的样子，不知道整天在忙什么。。。最近突然被问起帧同步相关的东西，感觉自己写了不少帧同步的逻辑但是又没什么好分享的就很伤感～想到前几天看到蛮有趣的文章，虽然不完全是帧同步相关的但是却很有参考价值，拿来随便翻译一下希望对大家稍微有帮助。。水平有限大家看看差不多就好了，贴出「<a href="http://www.gabrielgambetta.com/client-server-game-architecture.html" target="_blank" rel="noopener">原文地址</a>」希望英语好的同学直接去看原文不要被我误导就好～</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>本文是关于探索快节奏多人游戏的技术和算法系列的第一篇，因此对多人游戏概念非常熟悉的同学可以随意的跳过这一篇就好啦～因为接下来只是一些介绍性质的讨论。。。</p><p>任何类型的游戏开发都是某种挑战，然而在多人游戏中我们还有更多全新的问题函待解决～最最 Interesting 的地方在于其核心问题其实是人类和物理！- - 好吧其实是作弊和地理限制造成的网络延时。。</p><h2 id="PART-2-反作弊"><a href="#PART-2-反作弊" class="headerlink" title="PART 2 反作弊"></a>PART 2 反作弊</h2><p>『一切罪恶来源于作弊』</p><p>作为一名游戏开发者，你一般情况下都不怎么在意玩家在单机游戏中作弊，毕竟作弊者只能影响到自己，虽然他可能无法获得你设计的游戏体验，但毕竟买了游戏就有权利随便按照他们自己的想法玩。</p><p>在多人游戏中就完全不一样了。。在任何竞技性游戏中，作弊的玩家提升了他们自己的游戏体验不说，最万恶的是他还破坏了其他玩家的体验。作为一名开发者对此必然深恶痛绝，因为这极有可能导致玩家流失。</p><p>当然有很多方法可以反作弊，但是最重要的（也可能是唯一真正有效的）只有一条：不要信任任何玩家。永远从最坏的角度去考虑 - 即所有玩家都会试图作弊。</p><h2 id="PART-3-权威服务器和傀儡客户端"><a href="#PART-3-权威服务器和傀儡客户端" class="headerlink" title="PART 3 权威服务器和傀儡客户端"></a>PART 3 权威服务器和傀儡客户端</h2><p>这会导致一个看起来简单的解决方案 - 让游戏在服务器上运行从而始终在你的掌控之中，客户端只是一个功能有限的“播放器”。换句话说，客户端只发送输入（按键和命令等）到服务器，服务器运行游戏逻辑后将结果发回客户端。该方案通常被称为权威服务器，因为游戏世界中的一切都受到服务器的控制。</p><p>虽然你的服务器也有可能遭受攻击，但那种情况不在本文讨论范围之内。使用权威服务器可以很大程度上减少被破解的风险，比如说在你不信任客户端的角色血量的情况下，一个被破解的客户端可能显示有1W血，但事实上服务器知道该玩家只剩最后10点血了~所以无论客户端怎么破解当他被其他玩家攻击时就会瞬间爆炸并死亡。</p><p>同样地，如果你信任玩家的坐标的话，被破解的客户端会告诉服务器“<strong>我在 (10,10) </strong>”然后一秒钟后又说“<strong>我在 (20,10) </strong>”，这或许会导致该玩家穿墙或者比其他玩家速度更快之类的问题。相反，如果服务器知道玩家当前位置在 (10,10) 并且客户端告诉服务器“<strong>我想要向右移动一格</strong>”，此时服务器更新其内部状态使玩家到达新位置 (11,10)，然后将结果回复给该玩家。</p><p><img src="http://www.gabrielgambetta.com/img/fpm1-01.png" alt="A simple client-server interaction."></p><p>总的来说，服务器独立管理游戏状态，客户端发送其操作至服务器，服务器周期性的更新游戏状态，并将结果发回客户端，最终呈现在玩家的屏幕上。</p><h2 id="PART-4-考虑网络问题"><a href="#PART-4-考虑网络问题" class="headerlink" title="PART 4 考虑网络问题"></a>PART 4 考虑网络问题</h2><p>傀儡客户端在慢速回合制游戏中表现良好，例如策略游戏或卡牌游戏。在局域网中也不错，因为所有通信几乎是零延迟响应。但在非局域网条件下的快节奏多人游戏中完全行不通。</p><p>我们来讨论一下物理世界的状况，假设你在旧金山，连接到纽约的服务器，大概有 4000 km 的距离，考虑到即使是网络上的字节流也无法超光速传输，光速大约是 300,000 km/s 因此通讯耗时约 13 ms。</p><p>听起来感觉好像很快的样子，然而这只是假设数据沿直线以光速传输的理论最优解，现实生活中不太可能出现，数据在路由器中需要经过一系列跳跃，大多数情况都无法达到光速，路由器本身也会由于包的复制，检查和转发等行为而造成一定的延迟。</p><p>为了方便讨论，我们假设数据从客户端到服务器需要 50ms 的时间，这已经是很好的情况，那么如果要从纽约连接到东京的服务器呢？如果遭遇网络拥堵等状况呢？延迟 100ms 、200ms 甚至 500ms 都是有可能的。</p><p>再回到我们的例子，你的客户端发送了“<strong>我按下了向右按钮</strong>”到服务器，50ms 后服务器收到了该消息。我们假设服务器立即更新了游戏状态并回复结果。客户端仍然需要再过 50ms 才能收到“<strong>你现在在(1,0)点</strong>”的消息。</p><p>在你看来，你只是按下按钮后 1/10 秒的时间内没有响应，然后你的角色向右移动了1格。这种程度的「延迟」听起来或许不算什么，但感觉上却非常明显。而当延迟达到半秒钟的时候，这游戏就没法玩了。。。</p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>多人网络游戏非常有趣，但也带来了全新的挑战。权威服务器架构虽然对于解决作弊问题非常有效，但是若不加以修饰的直接使用会导致游戏反应非常迟钝。</p><p>在接下来的文章中，我们将探索如何在权威服务器的基础上最小化玩家的延迟感，从而达到单机游戏的体验。</p><hr><p>原文链接：<a href="https://snatix.com/2018/05/07/015-client-server-game-architecture/">https://snatix.com/2018/05/07/015-client-server-game-architecture/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;嗯。。。所以就翻译一下「快节奏多人游戏同步」这个系列吧～自从来柏林似乎就一直没有写文章的样子，不知道整天在忙什么。。。最近突然被问起帧同步相关的东西，感觉自己写了不少帧同步的逻辑但是又没什么好分享的就很伤感～想到前几天看到蛮有趣的文章，虽然不完全是帧同步相关的但是却很有参考价值，拿来随便翻译一下希望对大家稍微有帮助。。水平有限大家看看差不多就好了，贴出「&lt;a href=&quot;http://www.gabrielgambetta.com/client-server-game-architecture.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;」希望英语好的同学直接去看原文不要被我误导就好～&lt;/p&gt;
    
    </summary>
    
      <category term="快节奏多人游戏同步" scheme="https://snatix.com/categories/%E5%BF%AB%E8%8A%82%E5%A5%8F%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E5%90%8C%E6%AD%A5/"/>
    
    
      <category term="多人游戏" scheme="https://snatix.com/tags/%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F/"/>
    
      <category term="同步" scheme="https://snatix.com/tags/%E5%90%8C%E6%AD%A5/"/>
    
      <category term="客户端" scheme="https://snatix.com/tags/%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    
      <category term="服务器" scheme="https://snatix.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Unity自动化(3)-使用Shell脚本导出ipa</title>
    <link href="https://snatix.com/2017/04/04/014-automatic-export-ipa-with-shell/"/>
    <id>https://snatix.com/2017/04/04/014-automatic-export-ipa-with-shell/</id>
    <published>2017-04-04T17:34:25.000Z</published>
    <updated>2018-07-24T14:18:22.729Z</updated>
    
    <content type="html"><![CDATA[<p>本系列暂时弃坑 <del>可能永远都填不上了</del></p><a id="more"></a><p> <del>清明节在家睡了一天又看了一整天《生活大爆炸》发现只剩最后一天了- -12点起床洗澡吃饭以后，意识到每次假期都有一种刚起床就只剩最后一天的最后一个晚上的感觉好想哭。。。上周去了 UWA 最后就被迫鸽了大家一个周末，看来坚持每周写一篇文章的计划还是任重而道远啊～好了言归正传，我们回到自动化打包的话题，「<a href="http://snatix.com/2017/03/18/013-export-ipa-without-apple-id/">上一期</a>」中我们提到由于各种原因我们仅有 mobileprovision 文件和 p12 文件来导出 ipa的方法，感觉其实是很麻烦的，那么我们的目标就是让这一切自动化起来。</del></p><p><del><!--more--></del></p><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a><del>PART 1 概述</del></h2><p><del>我们的目标是，从 svn update 以后就可以直接运行一个 shell 脚本导出 ipa，无需任何额外操作。那么其实中间大概有这么几个步骤。</del></p><ol><li><del>打开 Unity 选择 Build XcodeProject</del></li><li><del>打开 Xcode 做一大堆配置</del></li><li><del>XcodeProject Archive</del></li><li><del>导出 ipa</del></li></ol><p><del>在写脚本的时候博主就尽量遵循简单易懂的原则方便大家阅读，尽量不写多余的控制逻辑，有需要的话大家可以自行扩展~首先在开始之前确保我们已经按照上一篇教程的方式成功导出过 ipa 从而确认环境没有太大的问题。</del></p><h2 id="PART-2-Build-XcodeProject"><a href="#PART-2-Build-XcodeProject" class="headerlink" title="PART 2 Build XcodeProject"></a><del>PART 2 Build XcodeProject</del></h2><hr><p>原文链接：<a href="https://snatix.com/2017/04/04/014-automatic-export-ipa-with-shell/">https://snatix.com/2017/04/04/014-automatic-export-ipa-with-shell/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本系列暂时弃坑 &lt;del&gt;可能永远都填不上了&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Unity通用框架工程" scheme="https://snatix.com/categories/Unity%E9%80%9A%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="mac" scheme="https://snatix.com/tags/mac/"/>
    
      <category term="ipa" scheme="https://snatix.com/tags/ipa/"/>
    
      <category term="shell" scheme="https://snatix.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Unity自动化(2)-无需企业开发帐号密码打包ipa</title>
    <link href="https://snatix.com/2017/03/18/013-export-ipa-without-apple-id/"/>
    <id>https://snatix.com/2017/03/18/013-export-ipa-without-apple-id/</id>
    <published>2017-03-18T12:24:08.000Z</published>
    <updated>2020-01-16T01:51:21.824Z</updated>
    
    <content type="html"><![CDATA[<p>终于迎来一个不用加班的周六可以愉快的写文章了。换了工位换了两台一样的显示器心情无比舒爽觉得终于要开展全新生活啦～之前两台显示器型号高矮全都不一样让我这样的强迫症患者超级难受 - -。言归正传，接下来我们来到了导出 ipa 的环节。通常在稍微规模大一点的公司是不会给开发者提供他们的具有开发者账户权限的 Apple Id 和密码的，因此想要导出 ipa 就只能通过公司提供的 p12 证书和 mobileprovision 描述文件，那么具体要怎么操作呢？</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>在「<a href="https://snatix.com/2017/03/12/012-export-unity-project-apk-on-mac/">上一期</a>」中我们介绍了在 mac 上导出 apk 的方法，那么现在来到了导出 ipa 的环节。正如引言所述，通常我们是没有企业开发帐号和密码的，只有 mobileprovision 和 p12 文件。目前 Xcode 版本已经达到 8.2 但是很多教程还停留在 7.x 甚至 6 的时代，有很多地方已经不适用了。所以接下来我们根据不同的 Xcode 版本来尝试打包一个带有企业证书的 inhouse 包并发布到服务器上可以允许任意用户远程安装。具体步骤如下：</p><ol><li>准备好一个 Unity 工程并将其导出 Xcode 工程</li><li>导入 p12 证书和 mobileprovision 描述文件</li><li>生成对应的 app 文件</li><li>将 app 文件转换成 ipa 文件</li><li>制作 plist 文件并发布到服务器</li></ol><h2 id="PART-2-将Unity工程导出xcode工程"><a href="#PART-2-将Unity工程导出xcode工程" class="headerlink" title="PART 2 将Unity工程导出xcode工程"></a>PART 2 将Unity工程导出xcode工程</h2><p>为了给大家演示又方便打包博主就简单的制作一个 Unity 工程吧，如图所示。。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017032001.png" alt="示例工程"></p><p>相信大家一眼就看出来了就只有一行代码把<code>Time.time</code>显示在屏幕中间。。好吧我们现在开始导出 xcode 工程。Build Settings 面板如下，点击<code>Build</code>再选一个路径就可以导出了，要注意的是<code>Run in Xcode as</code>必须要选择<code>Debug</code>才行，还有就是别忘了修改<code>Bundle Identifier</code>与证书一致，如果不知道的话可以留到 Xcode 工程中再修改。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017032002.png" alt="BuildSettings"></p><p>最后打开导出的目录双击<code>Unity-iPhone.xcodeproj</code>打开 Xcode 工程，成功！</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017032004.png" alt="Xcode工程"></p><h2 id="PART-2-导入-p12证书和-mobileprovision"><a href="#PART-2-导入-p12证书和-mobileprovision" class="headerlink" title="PART 2 导入.p12证书和.mobileprovision"></a>PART 2 导入.p12证书和.mobileprovision</h2><p>接下来的步骤可能不同版本的 Xcode 会不太一样，以博主的 Xcode 8.2.1 为例。打开以后如上图所示。可以看到有一个报错叫做<code>&quot;Signing for &quot;Unity-iPhone&quot; requires a development team&quot;</code>，一般来说如果自己拥有开发者帐号的话直接按照各种教程的步骤来就没问题了。但是很多时候我们并没有对应的企业开发者帐号的使用权限，只有如下图的两个文件。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017032005.png" alt="证书"></p><p>关于这两个文件的作用和来源这里就不再赘述了，总之很麻烦而且博主也没有企业级开发者帐号没有亲手操作过～通常公司的平台组会为我们准备好这两个文件。首先回到 Xcode 工程中，切换到<code>Signing</code>部分，取消<code>Automatically manage signing</code>。此时会出现多个要求导入<code>Provisioning Profile</code>的部分，如下图所示。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017032006.png" alt="证书"></p><p>接下来的操作很简单，只需要在每一个地方点击<code>Import Profile...</code>并选择之前的<code>example.mobileprovision</code>文件即可。如果之前没有修改<code>Bundle Identifier</code>的话，会有报错信息提示：<code>Provisioning profile &quot;xxxxxx&quot; has app ID &quot;com.xxx.xxx&quot;, which does not match the bundle ID &quot;com.snatic.example&quot;.</code> 按要求修改<code>Bundle Identifier</code>即可。</p><p>那么修复了这条报错以后，还会提示<code>No &quot;iOS Distribution&quot; signing certificate matching team ID &quot;xxxxxxxxx&quot; with a private key was found.</code>那么此时我们需要导入的就是刚才的 .p12 文件了，双击以后输入密码即可导入很方便。那么目前为止所有的报错全都解决了可以安全导出 ipa 了么？</p><h2 id="PART-3-生成app文件"><a href="#PART-3-生成app文件" class="headerlink" title="PART 3 生成app文件"></a>PART 3 生成app文件</h2><p>理论上此时我们就可以直接插上一台 iPhone 开始运行了，但是我们的目标是导出 ipa，因此按照正常流程往下走的话就是点击 Product -&gt; Archive 然后 Export 就好了，这个流程在 Xcode 7 中完全没有问题。但在 Xcode 8 中，会做如下提示。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017032007.png" alt="添加帐号"></p><p>在我们没有开发者帐号以及企业子帐号的情况下这一步没办法绕过了，在 Xcode 7 中可以直接选择<code>Use local signing assets</code>的选项但是这里并不会直接出现还是需要先登录。那么我们只能剑走偏锋了。</p><p>插上一台 iPhone 直接点击运行，等待编译和安装完成以后确认在设备上运行无误，然后我们就会在左侧看到 <code>XXXX.app</code>，如图所示。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017032008.png" alt="导出app"></p><p>右键点击该文件，选择<code>Show in Finder</code>即可找到我们至关重要的 app 文件。</p><h2 id="PART-4-将app转换为ipa"><a href="#PART-4-将app转换为ipa" class="headerlink" title="PART 4 将app转换为ipa"></a>PART 4 将app转换为ipa</h2><p>转换的方法有几种，限于篇幅(其实是太懒)博主就先介绍三种简单的方法，关于高级的自动化脚本的方法下次单独开一篇文章来介绍吧～</p><h3 id="方法一-拖入iTunes"><a href="#方法一-拖入iTunes" class="headerlink" title="方法一 拖入iTunes"></a>方法一 拖入iTunes</h3><p>打开 iTunes 切换到应用页，然后直接将上一步得到的 app 文件拖进来，就能得到如下图的应用。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017032201.png" alt="导出app"></p><p>右键点击应用 -&gt; 在 Finder 中显示 就可以得到我们所需要的 ipa 文件了。</p><h3 id="方法二-手动压缩改后缀"><a href="#方法二-手动压缩改后缀" class="headerlink" title="方法二 手动压缩改后缀"></a>方法二 手动压缩改后缀</h3><ol><li>新建“Payload”文件夹，注意大小写</li><li>将 app 文件放到<code>Payload</code>文件夹中</li><li>在<code>Payload</code>文件夹右键压缩成 zip 后将生成的 zip 文件后缀为 ipa</li></ol><p>感觉简单粗暴，这个过程明显可以写一个脚本来完成的。下次再慢慢讲脚本的问题～理想状态是可以不用打开 xcode 不用插手机就能直接导出，这样就可以一键导出 ipa 包了。</p><h2 id="PART-5-Inhouse发布"><a href="#PART-5-Inhouse发布" class="headerlink" title="PART 5 Inhouse发布"></a>PART 5 Inhouse发布</h2><p>其实发布 Inhouse 下载非常简单，如果按照正常打包流程的话 Xcode 是会为我们自动生成所需要的 plist 文件的，但是我们的流程比较奇怪所以需要新建一个文件，粘贴以下内容最后修改后缀为<code>plist</code></p><pre><code class="lang-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;dict&gt;    &lt;key&gt;items&lt;/key&gt;    &lt;array&gt;        &lt;dict&gt;            &lt;key&gt;assets&lt;/key&gt;            &lt;array&gt;                &lt;dict&gt;                    &lt;key&gt;kind&lt;/key&gt;                    &lt;string&gt;software-package&lt;/string&gt;                    &lt;key&gt;url&lt;/key&gt;                    &lt;string&gt;THE URL FOR YOUR IPA: ex: https://go.com/appname.ipa&lt;/string&gt;                &lt;/dict&gt;                &lt;dict&gt;                    &lt;key&gt;kind&lt;/key&gt;                    &lt;string&gt;full-size-image&lt;/string&gt;                    &lt;key&gt;needs-shine&lt;/key&gt;                    &lt;true/&gt;                    &lt;key&gt;url&lt;/key&gt;                    &lt;string&gt;THE URL FOR INSTALLATION @2x ICON: ex: https://go.com/Icon@2x.png&lt;/string&gt;                &lt;/dict&gt;                &lt;dict&gt;                    &lt;key&gt;kind&lt;/key&gt;                    &lt;string&gt;display-image&lt;/string&gt;                    &lt;key&gt;needs-shine&lt;/key&gt;                    &lt;true/&gt;                    &lt;key&gt;url&lt;/key&gt;                    &lt;string&gt;THE URL FOR INSTALLATION ICON: ex: https://go.com/Icon.png&lt;/string&gt;                &lt;/dict&gt;            &lt;/array&gt;            &lt;key&gt;metadata&lt;/key&gt;            &lt;dict&gt;                &lt;key&gt;bundle-identifier&lt;/key&gt;                &lt;string&gt;YOUR BUNDLE ID (Take it from your Xcode Project)&lt;/string&gt;                &lt;key&gt;bundle-version&lt;/key&gt;                &lt;string&gt;1.2.3 Your app version&lt;/string&gt;                &lt;key&gt;kind&lt;/key&gt;                &lt;string&gt;software&lt;/string&gt;                &lt;key&gt;title&lt;/key&gt;                &lt;string&gt;The Title To Present To The User installing the app&lt;/string&gt;            &lt;/dict&gt;        &lt;/dict&gt;    &lt;/array&gt;&lt;/dict&gt;&lt;/plist&gt;</code></pre><p>按照说明修改其中的字段以后将该文件与 ipa 一起上传支持 https 协议的服务器，没有的话就在 oschina 或者 coding,net 之类的新建一个 Git 仓库然后上传就没问题了，记得图标也要上传不然会有奇怪的无法下载的问题，图标大小不大于 500*500 就好。最后我们在任意一个网页上插入如下代码，在<code>url=</code>后面填写刚才上传的 plist 文件地址就好了。</p><pre><code class="lang-html">&lt;a href=&quot;itms-services://?action=download-manifest&amp;url=https://mydomain.com/apps/MyInHouseApp.plist&quot; id=&quot;text&quot;&gt;Install the In-House App&lt;/a&gt;</code></pre><p>用手机打开这个页面试试。点击链接就可以下载了果然很方便的样子。</p><h2 id="PART-6-总结"><a href="#PART-6-总结" class="headerlink" title="PART 6 总结"></a>PART 6 总结</h2><p>拖了小半周零零碎碎的总算是写完了，貌似没什么干货反而让截图占了很大的篇幅。但是为了把整个流程讲清楚多截几张图也还好。也许新版本的  Xcode 发布以后这篇教程就过期了～当前的 Xcode 版本是 8.2.1 不知道苹果会不会在以后的版本中采取更严格的方式限制打包。不过目前手动打包 ipa 的方法并不是我们的重点，下周我们一起研究自动打包脚本～</p><hr><p>原文链接：<a href="https://snatix.com/2017/03/18/013-export-ipa-without-apple-id/">https://snatix.com/2017/03/18/013-export-ipa-without-apple-id/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于迎来一个不用加班的周六可以愉快的写文章了。换了工位换了两台一样的显示器心情无比舒爽觉得终于要开展全新生活啦～之前两台显示器型号高矮全都不一样让我这样的强迫症患者超级难受 - -。言归正传，接下来我们来到了导出 ipa 的环节。通常在稍微规模大一点的公司是不会给开发者提供他们的具有开发者账户权限的 Apple Id 和密码的，因此想要导出 ipa 就只能通过公司提供的 p12 证书和 mobileprovision 描述文件，那么具体要怎么操作呢？&lt;/p&gt;
    
    </summary>
    
      <category term="Unity通用框架工程" scheme="https://snatix.com/categories/Unity%E9%80%9A%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="mac" scheme="https://snatix.com/tags/mac/"/>
    
      <category term="ipa" scheme="https://snatix.com/tags/ipa/"/>
    
      <category term="ios" scheme="https://snatix.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>Unity自动化(1)-在Mac上手动打包Apk</title>
    <link href="https://snatix.com/2017/03/12/012-export-unity-project-apk-on-mac/"/>
    <id>https://snatix.com/2017/03/12/012-export-unity-project-apk-on-mac/</id>
    <published>2017-03-12T21:41:48.000Z</published>
    <updated>2020-01-16T01:51:21.821Z</updated>
    
    <content type="html"><![CDATA[<p>失踪人口终于回归啦！好久没写文章了，因为找工作跳槽搬家入职适应环境什么的各种事情耽搁了好几周没抽出时间来静下心来研究一些东西。因为新项目中工作环境比较原始，打包 apk 和 ipa 都需要完全手动导出，甚至有些文件还需要自己手动复制很是麻烦，有些怀念之前用 jenkins 动动手指在任意电脑打开浏览器添加一系列任务吃个饭回来 30 个包就 OK 的日子，所以突然很想要把所有的一切自动化起来。</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>虽说我们的目标是完全自动化，但第一节课还是从入门开始(其实就是偷懒想少写一些内容)，也就是先把手动打包的流程整理清楚，因为考虑到如果想要同一台电脑想要同时打包 apk 和 ipa 所以我们的选择就只有 mac，mac 上打包 ipa 很常见了，那么如何在 mac 上为 unity 打包一个 apk 呢。其实坑还是挺多的，当然以下提到的一切都建立在可以「科学上网」的基础上。其实步骤很简单</p><ol><li>安装 JDK</li><li>安装 Android SDK</li><li>安装 NDK</li><li>使用 Android 虚拟机验证</li></ol><h2 id="PART-2-安装-JDK"><a href="#PART-2-安装-JDK" class="headerlink" title="PART 2 安装 JDK"></a>PART 2 安装 JDK</h2><p>博主使用的是 Unity5.5.0f3 的版本，其实配置起来还是比较方便的。当然前提是我们已经安装 Unity Android Support以后，切换到 Android Platform 打开 Unity Preference 以后可以看到需要配置的地方都提供了<code>Download</code>按钮，点击一下就可以跳转到具体的官网页面下载了当然如果没有「科学上网」的帮助的话很可能这些页面完全打不开或者下载速度不忍直视。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017031201.png" alt="配置环境"></p><p>首先我们第一步是下载 JDK，点击对应的「Download」就可以调转到 <a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">ORACLE官网下载页</a> 进行下载了。貌似没有太多复杂的东西好说，找到 JDK 也就是 Java SE Development Kit 的下载页进入以后选择好相应的平台下载，最后一路安装就没问题了，英语水平正常的话完全没有任何要注意的坑所以就不截图了。安装好一般来说路径就跟博主图里的路径是差不多的。</p><p>最后在 Terminal 里输入<code>java -version</code>试试有版本号信息的话出现就表示安装成功了。最后确认好位置填入到 Unity Prefrences 里面 JDK 一项就好了。</p><h2 id="PART-3-安装-Android-Studio"><a href="#PART-3-安装-Android-Studio" class="headerlink" title="PART 3 安装 Android Studio"></a>PART 3 安装 Android Studio</h2><p>这一步是安装 Android SDK，目前来说安装 Android SDK 的一般方式就是安装好 Android Studio 然后打开 SDK Manager 来管理所有的 Android SDK，当然也可以直接下载好放在某个位置设置路径就行了但是博主不喜欢来历不明比较奇怪的东西，毕竟以后要接渠道 SDK 也用得到 Android Studio 顺便安装一个也省心。</p><p> 点击 Unity Prefrences 中 SDK 项后面的<code>Download</code>进入 <a href="https://developer.android.com/sdk/index.html#Other" target="_blank" rel="noopener">Android Studio 官方下载页</a> 直接点击下载即可</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017031202.png" alt="官方下载页"></p><p>这个官网还挺好看的就截一张图吧。一路安装好以后首次打开会帮你下载好最新的 Andriod SDK 和 SDK Tools 之类的东西，很方便。最后在 Unity Prefrences 中配置路径就好了就跟博主的还是差不多的路径。</p><p>什么这样就结束了么？当然会有坑的不然这篇文章也没必要写了。提示 NDK 如果不用 IL2CPP 的话留白就好了，但这时候我们点击<code>Build</code>会发现并不能正常出包，大概会报如下的错</p><pre><code class="lang-text">CommandInvokationFailure: Unable to list target platforms. Please make sure the android sdk path is correct. See the Console for more details. /Library/Java/JavaVirtualMachines/jdk1.8.0_121.jdk/Contents/Home/bin/java -Xmx2048M -Dcom.android.sdkmanager.toolsdir=&quot;/Users/snatic/Library/Android/sdk/tools&quot; -Dfile.encoding=UTF8 -jar &quot;/Applications/Unity/PlaybackEngines/AndroidPlayer/Tools/sdktools.jar&quot; -stderr[Error:Invalid command android]stdout[]exit code: 64UnityEditor.Android.Command.Run (System.Diagnostics.ProcessStartInfo psi, UnityEditor.Android.WaitingForProcessToExit waitingForProcessToExit, System.String errorMsg)UnityEditor.Android.AndroidSDKTools.RunCommandInternal (System.String javaExe, System.String sdkToolsDir, System.String[] sdkToolCommand, Int32 memoryMB, System.String workingdir, UnityEditor.Android.WaitingForProcessToExit waitingForProcessToExit, System.String errorMsg)UnityEditor.Android.AndroidSDKTools.RunCommandSafe (System.String javaExe, System.String sdkToolsDir, System.String[] sdkToolCommand, Int32 memoryMB, System.String workingdir, UnityEditor.Android.WaitingForProcessToExit waitingForProcessToExit, System.String errorMsg)UnityEditor.HostView:OnGUI()</code></pre><p>那么是哪里出了问题呢，博主在这个地方头疼好久最终找到了解决方案，就是回到刚才的  <a href="https://developer.android.com/sdk/index.html#Other" target="_blank" rel="noopener">Android Studio 官方下载页</a> 拉到底部，找到「仅获取命令行工具」的地方选择对应平台的下载，解压后复制到 SDK目录下，例如<code>/Users/snatic/Library/Android/sdk</code>，再替换原来的<code>tools</code>文件夹。</p><p>最后设置环境变量，在 Terminal 中输入</p><pre><code class="lang-bash">export ANDROID_SDK_HOME=&quot;/Users/snatic/Library/Android/sdk&quot;</code></pre><p>需要注意的是，下次打开 Android Studio 的时候可能会提示 SDK Tools 有更新，点击忽略即可。不然下次打包又会悲剧的重新替换一遍不要问我怎么知道的。。。</p><h2 id="PART-4-安装-NDK"><a href="#PART-4-安装-NDK" class="headerlink" title="PART 4 安装 NDK"></a>PART 4 安装 NDK</h2><p>不了解 IL2CPP 或者只打算用 mono 的同学到目前位置应该差不多可以打包了，如果想要使用 IL2CPP 的话我们还需要下载 NDK，需要注意的是我们并不能使用 Android Studio 中的 SDK Manager 来安装 NDK。需要按照 Unity Prefrence 的指引，我们会得到一个名为<code>android-ndk-r10e-darwin-x86_64.bin</code>的文件，然而这个文件如何使用呢？首先进入到该文件所在目录，输入以下命令更改文件的读写权限</p><pre><code class="lang-bash">chmod a+x android-ndk-r10e-darwin-x86_64.bin</code></pre><p>再运行以下命令执行该文件</p><pre><code class="lang-bash">./android-ndk-r10e-darwin-x86_64.bin</code></pre><p>这样我们就会得到一个文件夹就是我们所需要的 NDK 了，把它移动到喜欢的目录就好了，博主将它和 Android SDK 放在一起了，最后在 Unity Prefrences 中填写路径，完成配置，可以使用 IL2CPP 打包 APK 了。</p><h2 id="PART-5-使用-Android-Studio-自带的虚拟机"><a href="#PART-5-使用-Android-Studio-自带的虚拟机" class="headerlink" title="PART 5 使用 Android Studio 自带的虚拟机"></a>PART 5 使用 Android Studio 自带的虚拟机</h2><p>生成 APK 文件以后当然是想要迫不及待的验证一下到底对不对了，那么如何创建 Android 虚拟机呢？首先打开 Android Studio 随便新建一个工程如图所示。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017031203.png" alt="Android Studio"></p><p>依次打开<code>Tools -&gt; Android -&gt; AVD Manager</code>，按照指引选择机型后下载对应版本的系统镜像文件并创建虚拟机，最后点击绿色箭头运行即可。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017031204.png" alt="Android Studio"></p><p>最后把生成好的 APK 拖到虚拟机中即可安装运行了，随便搭一个场景写点代码试一试效果吧~</p><h2 id="PART-6-总结"><a href="#PART-6-总结" class="headerlink" title="PART 6 总结"></a>PART 6 总结</h2><p>好像这么结束的确有点水不过作为系列的第一篇还是情有可原的。替换 tools 文件夹真的坑了我好久，最后还是在万能的 stackoverflow「<a href="http://stackoverflow.com/questions/42538433/not-finding-android-sdk-unity#" target="_blank" rel="noopener">这个页面</a>」 找到了解决方案。以后的版本也许就会修复这个问题不用这么麻烦了，但是目前为止因为没有 Assetbundle 要处理，也没有渠道 SDK 资源替换之类的操作，所以本质上就是一键打包 apk 的，但是 ipa 就不同了需要我们先导出 xcode 工程，搞定烦人的证书以后再导出 ipa 安装。很想自动化处理这一切，一起拭目以待吧。</p><hr><p>原文链接：<a href="https://snatix.com/2017/03/12/012-export-unity-project-apk-on-mac/">https://snatix.com/2017/03/12/012-export-unity-project-apk-on-mac/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;失踪人口终于回归啦！好久没写文章了，因为找工作跳槽搬家入职适应环境什么的各种事情耽搁了好几周没抽出时间来静下心来研究一些东西。因为新项目中工作环境比较原始，打包 apk 和 ipa 都需要完全手动导出，甚至有些文件还需要自己手动复制很是麻烦，有些怀念之前用 jenkins 动动手指在任意电脑打开浏览器添加一系列任务吃个饭回来 30 个包就 OK 的日子，所以突然很想要把所有的一切自动化起来。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity通用框架工程" scheme="https://snatix.com/categories/Unity%E9%80%9A%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="mac" scheme="https://snatix.com/tags/mac/"/>
    
      <category term="android" scheme="https://snatix.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>重启Hexo(3)-添加打赏功能</title>
    <link href="https://snatix.com/2017/02/13/011-hexo-blog-donate-plugin/"/>
    <id>https://snatix.com/2017/02/13/011-hexo-blog-donate-plugin/</id>
    <published>2017-02-13T11:18:53.000Z</published>
    <updated>2020-01-16T01:51:21.822Z</updated>
    
    <content type="html"><![CDATA[<p>因为在『<a href="https://snatix.com/about/">关于我</a>』页面中承诺要制作打赏功能拖延一个月还没开始动手，被某小盆友吐槽以后决定奋发图强的瞬间做好了。但是当时制作过程太紧迫就没有一步一步的记录下来，现在就稍微补一下吧～其实过程太简单所以这篇文章应该内容很少，但的确很好用～</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>距离系列的『<a href="http://snatix.com/2017/01/14/008-customize-hexo/">上一篇</a>』过去了一个多月终于迎来了更新，那就是「打赏」功能！其实这样的需求不算少，大家随便用「hexo」「打赏」这样的关键词百度一下就会发现很多很多转载来转载去的文章，翻来覆去讲的大概就是那些内容，很多都是为某个特殊主题服务的，或者是主题框架与自己使用的主题完全不同，就会导致很多麻烦的问题。可能很多同学没有打算深入研究某个主题，因此也对主题框架一知半解，花时间解决那些问题还挺麻烦的，就想简简单单的复制一段代码就实现的打赏功能难道不存在么？当然存在</p><ol><li>在主题文章内容的 ejs 文件里插入关键代码</li><li>在博客<code>_config.yml</code>中定义二维码链接</li><li>在需要添加打赏功能的文章顶部添加标识</li></ol><h2 id="PART-2-在关键位置插入关键代码"><a href="#PART-2-在关键位置插入关键代码" class="headerlink" title="PART 2 在关键位置插入关键代码"></a>PART 2 在关键位置插入关键代码</h2><p>既然说关键代码当然很关键了，最关键的是代码是整体的。不存在一部分放在某个地方，另一部分放在其他地方然后相互调用的问题，完美方便懒得了解自己正在用的主题的框架的同学。当然，这段代码具体插在哪里还是有讲究的。总之大家先查看以下代码。</p><pre><code class="lang-html">&lt;% if (page.donate) { %&gt;&lt;!-- css --&gt;&lt;style type=&quot;text/css&quot;&gt;  .center {    text-align: center;  }  .hidden {    display: none;  }  .donate_bar a.btn_donate{    display: inline-block;    width: 82px;    height: 82px;    background: url(&quot;https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/DonateButton.gif&quot;) no-repeat;    _background: url(&quot;https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/DonateButton.gif&quot;) no-repeat;    -webkit-transition: background 0s;    -moz-transition: background 0s;    -o-transition: background 0s;    -ms-transition: background 0s;    transition: background 0s;  }  .donate_bar a.btn_donate:hover{ background-position: 0px -82px;}  .donate_bar .donate_txt {    display: block;    color: #9d9d9d;    font: 14px/2 &quot;Microsoft Yahei&quot;;  }  .bold{ font-weight: bold; }&lt;/style&gt;&lt;!-- /css --&gt;&lt;!-- Donate Module --&gt;&lt;div id=&quot;donate_module&quot;&gt;  &lt;!-- btn_donate &amp; tips --&gt;  &lt;div id=&quot;donate_board&quot; class=&quot;donate_bar center&quot;&gt;    &lt;a id=&quot;btn_donate&quot; class=&quot;btn_donate&quot; target=&quot;_self&quot; href=&quot;javascript:;&quot; title=&quot;Donate 打赏&quot;&gt;&lt;/a&gt;    &lt;span class=&quot;donate_txt&quot;&gt;      &lt;%= theme.donate.text %&gt;    &lt;/span&gt;  &lt;/div&gt;  &lt;!-- /btn_donate &amp; tips --&gt;  &lt;!-- donate guide --&gt;  &lt;div id=&quot;donate_guide&quot; class=&quot;donate_bar center hidden&quot;&gt;    &lt;a href=&quot;&lt;%= theme.donate.wechat %&gt;&quot; title=&quot;用微信扫一扫哦~&quot; class=&quot;fancybox&quot; rel=&quot;article0&quot;&gt;      &lt;img src=&quot;&lt;%= theme.donate.wechat %&gt;&quot; title=&quot;微信打赏 snatic&quot; height=&quot;190px&quot; width=&quot;auto&quot;/&gt;    &lt;/a&gt;    &lt;a href=&quot;&lt;%= theme.donate.alipay %&gt;&quot; title=&quot;用支付宝扫一扫即可~&quot; class=&quot;fancybox&quot; rel=&quot;article0&quot;&gt;      &lt;img src=&quot;&lt;%= theme.donate.alipay %&gt;&quot; title=&quot;支付宝打赏 snatic&quot; height=&quot;190px&quot; width=&quot;auto&quot;/&gt;    &lt;/a&gt;    &lt;span class=&quot;donate_txt&quot;&gt;      &lt;%= theme.donate.text %&gt;    &lt;/span&gt;  &lt;/div&gt;  &lt;!-- /donate guide --&gt;  &lt;!-- donate script --&gt;  &lt;script type=&quot;text/javascript&quot;&gt;    document.getElementById(&#39;btn_donate&#39;).onclick = function() {      $(&#39;#donate_board&#39;).addClass(&#39;hidden&#39;);      $(&#39;#donate_guide&#39;).removeClass(&#39;hidden&#39;);    }    function donate_on_web(){      $(&#39;#donate&#39;).submit();    }    var original_window_onload = window.onload;    window.onload = function () {      if (original_window_onload) {        original_window_onload();      }      document.getElementById(&#39;donate_board_wdg&#39;).className = &#39;hidden&#39;;    }  &lt;/script&gt;  &lt;!-- /donate script --&gt;&lt;/div&gt;&lt;!-- /Donate Module --&gt;</code></pre><p>还挺长的，但是排版缩进博主都整理好了大家勇敢的复制粘贴吧。那么复制粘贴到哪里呢，这的确是一个问题。通常是位于<code>themes/xxx/layout/_partial/</code>之类的目录下面，找到类似<code>post-content.ejs</code>或者看着名字像是文章正文的文件中合适的位置，一般是<code>&lt;%- page.content %&gt;</code>这一行的后面。。。</p><p>好吧我承认我表达的有点隐晦，不过大家都是聪明的程序猿或者攻城狮，随便试试就试出来了，当然了解结构的同学可以自行根据需要添加在文章开头也是没什么问题的～</p><h2 id="PART-3-填写全局配置"><a href="#PART-3-填写全局配置" class="headerlink" title="PART 3 填写全局配置"></a>PART 3 填写全局配置</h2><p>这一步就很简单了打开位于根目录下的<code>_config.yml</code>文件，在最后添加如下代码并且把内容改成你想要的配置就好了。</p><pre><code class="lang-yaml"># Donatedonate:  text: 一定会有好心人支持我的，一块两块的就好～  wechat: https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/WechatImage.png  alipay: https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/AlipayImage.png</code></pre><p><code>text</code>就是显示在「赏」字下面的那一行小字，然后<code>wechat</code>和<code>alipay</code>分别对应微信和支付宝的收款二维码（不要贴成付款二维码了），最好截图以后稍微放到 Photoshop 里面处理一下，毕竟美观一些大家付款的欲望也会更强的……吧。</p><h2 id="PART-4-为想要的文章开启打赏功能"><a href="#PART-4-为想要的文章开启打赏功能" class="headerlink" title="PART 4 为想要的文章开启打赏功能"></a>PART 4 为想要的文章开启打赏功能</h2><p>最后也是最关键的一步，很多人不管什么文章都喜欢在后面放一个大大的「赏」字好像这个字出现次数越多就会收到打赏的机率越高一样。。。然而博主并不这么认为，因为隐隐约约觉得好像在乞讨一样～所以可以选择性的为某篇文章开启打赏功能当然是必备的。只需要在文章顶部的<code>front-matter</code>添加<code>donate</code>即可，像是这样。</p><pre><code class="lang-yaml">title: 重启Hexo(3)-添加打赏功能date: 2017-02-13 12:18:53tags: [hexo, mac, blog]categories: Hexo博客重启计划donate: true</code></pre><p>作为有节操的博主本来是只在「关于我」这样的页面放一个打赏的入口，心里默默计划着万一哪天真的写了一篇特别厉害的文章说不定也会加入（比如这篇？）好吧其实是放一个按钮给大家点一点让大家能够直观的看到效果。</p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>目前为止打赏功能就算是完成了，看起来挺简单的因为文章里省略了最耗时的过程——用 PS 处理二维码，为了美观也是竭尽全力～好吧这次本系列下次更新可能要好久好久了，因为主题也慢慢的稳定下来～以前喜欢折腾主题不喜欢写文章的习惯已经在慢慢的改变了，希望以后能再勤劳一些写更多的文章～打赏功能不出意外的话应该会显示在文章底部喽～</p><hr><p>原文链接：<a href="https://snatix.com/2017/02/13/011-hexo-blog-donate-plugin/">https://snatix.com/2017/02/13/011-hexo-blog-donate-plugin/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为在『&lt;a href=&quot;https://snatix.com/about/&quot;&gt;关于我&lt;/a&gt;』页面中承诺要制作打赏功能拖延一个月还没开始动手，被某小盆友吐槽以后决定奋发图强的瞬间做好了。但是当时制作过程太紧迫就没有一步一步的记录下来，现在就稍微补一下吧～其实过程太简单所以这篇文章应该内容很少，但的确很好用～&lt;/p&gt;
    
    </summary>
    
      <category term="Hexo博客重启计划" scheme="https://snatix.com/categories/Hexo%E5%8D%9A%E5%AE%A2%E9%87%8D%E5%90%AF%E8%AE%A1%E5%88%92/"/>
    
    
      <category term="mac" scheme="https://snatix.com/tags/mac/"/>
    
      <category term="hexo" scheme="https://snatix.com/tags/hexo/"/>
    
      <category term="blog" scheme="https://snatix.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>Assetbundle(2)-学习Assetbundle Manager</title>
    <link href="https://snatix.com/2017/01/29/010-using-assetbundle-manager/"/>
    <id>https://snatix.com/2017/01/29/010-using-assetbundle-manager/</id>
    <published>2017-01-29T14:02:53.000Z</published>
    <updated>2020-01-16T01:51:21.822Z</updated>
    
    <content type="html"><![CDATA[<p>过完年稍微出去浪了一天终于决定重新开始好好学习天天向上了～在上一篇文章『<a href="http://snatix.com/2017/01/15/009-start-with-asset-bundle/">Assetbundle(1)-初次接触</a>』中简单地讲解了 Assetbundle 最基本的使用方法，那么最基本的使用和项目中稳定的使用是有很大的区别的~有太多细节需要处理。那么今天就来学习一个神器「<a href="https://www.assetstore.unity3d.com/en/#!/content/45836" target="_blank" rel="noopener">AssetBundle Manager</a>」</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>AssetBundle Manager 其实是 Unity 官方提供的一个用于开发者方便的管理 Assetbundle 的一个插件。这里有详细的 <a href="https://unity3d.com/cn/learn/tutorials/topics/scripting/assetbundles-and-assetbundle-manager" target="_blank" rel="noopener">官方教程</a> ，但是这篇文章并不打算把教程翻译一遍了事 (其实是英文水平差又懒)。博主准备用自己的方式来详细讲解这个插件的用法，最后合理的把它集成在我们的 Asset Manager 中～毕竟重复造轮子不仅累而且技术含量也高。。那么接下来将会涉及到以下几个方面</p><ol><li>API介绍</li><li>尝试各种方式加载资源和场景</li><li>Variants 这种高级用法</li><li>一些好玩的小功能</li></ol><h2 id="PART-2-API-介绍"><a href="#PART-2-API-介绍" class="headerlink" title="PART 2 API 介绍"></a>PART 2 API 介绍</h2><p>虽然博主是行动派喜欢自己动手试试，但是简单的介绍还是需要的，因为没太多可以讲的博主决定就抄官方文档了。。</p><blockquote><p>The AssetBundle Manager’s API includes:</p><ul><li><strong><em>Initialize()</em></strong> Initializes the AssetBundle manifest object.</li><li><strong><em>LoadAssetAsync()</em></strong> Loads a given asset from a given AssetBundle and handles all the dependencies.</li><li><strong><em>LoadLevelAsync()</em></strong> Loads a given scene from a given AssetBundle and handles all the dependencies.</li><li><strong><em>LoadDependencies()</em></strong> Loads all the dependent AssetBundles for a given AssetBundle.</li><li><strong><em>BaseDownloadingURL</em></strong> Sets the base downloading url which is used for automatic downloading dependencies.</li><li><strong><em>SimulateAssetBundleInEditor</em></strong> Sets Simulation Mode in the Editor.</li><li><strong><em>Variants</em></strong> Sets the active variant.</li><li><strong><em>RemapVariantName()</em></strong> Resolves the correct AssetBundle according to the active variant.</li></ul></blockquote><p>大概就是讲有以下 API：</p><ul><li><strong>Initialize()</strong> 初始化 AssetBundle Manifest 对象</li><li><strong>LoadAssetAsync()</strong> 从指定的一个 AssetBundle 中加载指定资源并处理所有的依赖</li><li><strong>LoadLevelAsync()</strong> 从指定的一个 AssetBundle 中加载指定场景并处理所有的依赖</li><li><strong>LoadDependencies()</strong> 加载指定的 AssetBundle 的所有依赖 AssetBundle</li><li><strong>BaseDownloadingURL</strong> 设置用来自动下载依赖的基本地址</li><li><strong>SimulateAssetBundleInEditor</strong> 在编辑器中设置模拟模式</li><li><strong>Variants</strong> 设置当前激活的 Variant</li><li><strong>RemapVariantName()</strong> 根据当前的变体决定正确的 AssetBundle</li></ul><p>Api 似乎非常简洁正式我想要的，不知道用起来是不是很复杂呢？Asset Store 里下载下来该 <a href="https://www.assetstore.unity3d.com/en/#!/content/45836" target="_blank" rel="noopener">插件</a> 会自带一个 Demo 大家可以根据需求自行参考～</p><h2 id="PART-3-尝试加载资源和场景"><a href="#PART-3-尝试加载资源和场景" class="headerlink" title="PART 3 尝试加载资源和场景"></a>PART 3 尝试加载资源和场景</h2><p>接下来必然要在我们的 AssetManager 工程中来使用这个插件了，首先我们需要在 Asset store 中找到这个 <a href="https://www.assetstore.unity3d.com/en/#!/content/45836" target="_blank" rel="noopener">插件</a> 。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017012901.png" alt="Asset Store"></p><p>作为一个洁癖当然不会随便的把 Example 和 README 什么的导入进来了～想看的话可以到另一个工程里看一看</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017012902.png" alt="导入"></p><p>完成以后就把整个文件夹移动到 AssetManager 文件夹下让他成为我们插件的一部分～(蜜汁觉得好像哪里不太对不过算了先这样吧)。因为这次的主要目的是使用这个插件所以我们暂时就不做任何修改了，原汁原味的使用～</p><h3 id="使用插件生成一次-AssetBundle"><a href="#使用插件生成一次-AssetBundle" class="headerlink" title="使用插件生成一次 AssetBundle"></a>使用插件生成一次 AssetBundle</h3><p>因为之前我们已经做过一次依赖测试所以资源就不需要再添加了，不明白的同学请先看「<a href="https://snatix.com/2017/01/15/009-start-with-asset-bundle/">上一篇</a>」，直接点击菜单<code>Assets/AssetBundles/Build AssetBundles</code>就可以生成想要的 AssetBundle 了。如图所示，插件在我们 Asset 同级目录下生成了<code>AssetBundles/OSX</code>目录并把生成好的 Bundle 放在里面。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017012903.png" alt="AssetBundles"></p><p>按照相同的目录结构把生成的文件放在 http 服务器上这样准备工作就完成了~记得把<code>Asset/AssetBundles/Simulation Mode</code>关掉不然就只是模拟模式。。。</p><h3 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h3><p>直接新建一个场景 <code>example_3</code> 再新建一个脚本<code>Example_3.cs</code>就可以了开始测试了。如以下代码</p><pre><code class="lang-csharp">IEnumerator LoadDependenciesAndPrefab(){    AssetBundleManager.SetSourceAssetBundleURL(Config.ABServerRootPath);    yield return AssetBundleManager.Initialize();    AssetBundleLoadAssetOperation request = AssetBundleManager.LoadAssetAsync(&quot;prefab_2&quot;, &quot;prefab_2&quot;, typeof(GameObject));    yield return StartCoroutine(request);    GameObject prefab = request.GetAsset&lt;GameObject&gt;();    GameObject.Instantiate(prefab);}</code></pre><p>直接在<code>Start</code>函数中开启协程调用以上函数，发现已经可以了～不需要处理依赖什么的，就好像异步加载本地资源一样非常方便。</p><h3 id="加载场景"><a href="#加载场景" class="headerlink" title="加载场景"></a>加载场景</h3><p>首先制作一个场景，制作的步骤不说了大概就是从 Asset Store 里随便下载一个免费的场景，然后把必要的资源移动到我们规划好的文件夹里- - 最后设置好 AssetBundle Name 就好了。最终效果大概是下图这样</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017020101.png" alt="场景完成"></p><p>那么资源的具体位置不多说了总之就是按照资源的类型分别放在<code>Materials</code>,<code>Modles</code>,<code>Prefabs</code>,<code>Scenes</code>,<code>Textures</code> 等文件夹里。需要注意的是，场景文件不可以和普通的资源文件设置相同的 AssetBundle Name，因此我们把场景文件最后生成一下 Assetbundle 看看～</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017020102.png" alt="生成的文件"></p><p>生成好的文件如上图所示，<code>scene_4</code>很小只有100K左右，查看其 manifest 文件可以得出以下依赖关系（没装 visio 之类的随便用一个 vscode 插件画了一下）</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017020103.png" alt="依赖关系"></p><p>那么这种复杂的依赖关系是不是处理起来很麻烦呢~答案显然是否。。使用 AssetBundle Manager 可以轻松搞定，新建一个空场景拖一个空 GameObject 然后挂上一个名叫 Example_4 的脚本，注意看以下代码。</p><pre><code class="lang-csharp">IEnumerator LoadDependenciesAndScene(){    AssetBundleManager.SetSourceAssetBundleURL(Config.ABServerRootPath);    yield return AssetBundleManager.Initialize();    AssetBundleLoadOperation request = AssetBundleManager.LoadLevelAsync(&quot;scene_4&quot;, &quot;CalibrationScene&quot;, false);    yield return StartCoroutine(request);}</code></pre><p>同样啰嗦了很多遍的在<code>Start</code>函数里开启一个协程调用以上代码就可以加载出来场景了（可能要等待10秒钟或更久）是不是很好很强大～效果为了提高网页加载速度就不贴那么多图了跟之前的差不多～大家自己试试吧。</p><h2 id="PART-4-Variants-的用法"><a href="#PART-4-Variants-的用法" class="headerlink" title="PART 4 Variants 的用法"></a>PART 4 Variants 的用法</h2><p>至于 Variants 到底是什么和具体使用场景就不细说了毕竟博主也没真正在项目中使用这个东西，欲了解精准概念请移步「<a href="https://docs.unity3d.com/Manual/BuildingAssetBundles.html" target="_blank" rel="noopener">官方文档</a>」，但是据博主观察大多数例子都举相同资源的不同质量的贴图，hd，sd之类的。以之前加载的场景为例，最终的贴图的依赖位于整个依赖链的最后，假设我们要准备两个不同贴图分辨率的场景的话，可能要从头到尾很多东西包括 material，mode 和 prefab 什么的都要重新制作一遍，造成了极大的浪费，否则就要写代码去动态加载要额外处理很多事情。那么现在 Assetbundle 就提供了这样的一个后缀一样的参数，允许你设置当前的 Variants 然后再去加载场景，这样就可以前面所有的东西都一样，只为两套不同分辨率的贴图制作两个 AssetBundle，加载的时候就根据当前的 Variants 把所需要的贴图所在的 Assetbundle 下载并 Load 所需要的贴图了。废话说了不少可能具体怎么操作大家还是不太明白，简单的尝试一下吧</p><p>首先在<code>Examples/Textures/</code>下建立两个文件夹命名不一样就行，然后把两个<strong>相同名称</strong>的资源分别放进去设置<strong>相同的</strong> AssetBundle Name，然后分别设置<strong>不同的</strong> Variants （以”a”，”b”为例）。最后制作 prefab 引用其中任何一个资源即可，最后制作场景添加脚本什么的就不想细说了。重点是观察以下代码</p><pre><code class="lang-csharp">IEnumerator LoadDependenciesAndScene(){    AssetBundleManager.SetSourceAssetBundleURL(Config.ABServerRootPath);    AssetBundleManager.ActiveVariants = new string[] {&quot;b&quot;};    yield return AssetBundleManager.Initialize();    AssetBundleLoadAssetOperation request = AssetBundleManager.LoadAssetAsync(&quot;prefab_5&quot;, &quot;prefab_5&quot;, typeof(GameObject));    yield return StartCoroutine(request);    GameObject prefab = request.GetAsset&lt;GameObject&gt;();    GameObject.Instantiate(prefab);}</code></pre><p>需要注意的就只有<code>AssetBundleManager.ActiveVariants = new string[] {&quot;b&quot;};</code>这一行，其他的都是复制粘贴过来的几乎完全一样。。自己尝试该代码运行会发现加载进来的 prefab 所依赖的贴图会随着这里填写不同的 Variants 自动切换。而制作 prefab 时完全无需考虑这一点，也不用再写其他的代码加载，非常方便的样子～</p><h2 id="PART-5-一些有趣的小功能"><a href="#PART-5-一些有趣的小功能" class="headerlink" title="PART 5 一些有趣的小功能"></a>PART 5 一些有趣的小功能</h2><h3 id="Simulation-Mode"><a href="#Simulation-Mode" class="headerlink" title="Simulation Mode"></a>Simulation Mode</h3><p>最后来探索以下 Assetbundle Manager 还有什么有趣的小功能吧，还记得之前让大家关闭的<code>Assets/AssetBundles/Simulation Mode</code>的功能么？那我们打开会如何呢？是的大家会发现即使你关掉我们用来下载 Assetbundle 的 http 服务也可以正常加载，而且无需重新生成 bundle 就可以更新资源。这极大的简化了我们的开发流程，不需要额外的资源管理机制就可以迅速看到 Assetbundle 中的改动效果而无需先重新生成一遍再放到服务器上。</p><h3 id="Local-AssetBundle-Server"><a href="#Local-AssetBundle-Server" class="headerlink" title="Local AssetBundle Server"></a>Local AssetBundle Server</h3><p>只是在本地直接模拟还是不够满意的，就是想模拟远程下载怎么办，只需要开启<code>Assets/AssetBundles/Local AssetBundle Server</code>就好了，因为博主电脑是 mac 各种麻烦的原因开启的时候总会报错可能要安装高版本的 mono 或者有其他的解决方案，下次找到了方法再补充，所以现在也不知道到底有多好用～Windows 上的大家应该用起来爽爽的~</p><h2 id="PART-6-总结"><a href="#PART-6-总结" class="headerlink" title="PART 6 总结"></a>PART 6 总结</h2><p>到此为止关于神奇的插件 AssetBundle Manager 就基本上介绍完了，总的来说是一个非常方便的插件，一口气帮助我们解决了许多细节问题而且感觉非常靠谱的样子。下一步就是完成一个自动设置 AssetBundle Name 的功能了，然后针对插件进行一些魔改了。不知道多久可以做好，等思路差不多的时候就开始更新下一篇！</p><hr><p>原文链接：<a href="https://snatix.com/2017/01/29/010-using-assetbundle-manager/">https://snatix.com/2017/01/29/010-using-assetbundle-manager/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;过完年稍微出去浪了一天终于决定重新开始好好学习天天向上了～在上一篇文章『&lt;a href=&quot;http://snatix.com/2017/01/15/009-start-with-asset-bundle/&quot;&gt;Assetbundle(1)-初次接触&lt;/a&gt;』中简单地讲解了 Assetbundle 最基本的使用方法，那么最基本的使用和项目中稳定的使用是有很大的区别的~有太多细节需要处理。那么今天就来学习一个神器「&lt;a href=&quot;https://www.assetstore.unity3d.com/en/#!/content/45836&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AssetBundle Manager&lt;/a&gt;」&lt;/p&gt;
    
    </summary>
    
      <category term="Unity通用框架工程" scheme="https://snatix.com/categories/Unity%E9%80%9A%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="asset bundle" scheme="https://snatix.com/tags/asset-bundle/"/>
    
  </entry>
  
  <entry>
    <title>Assetbundle(1)-初次接触</title>
    <link href="https://snatix.com/2017/01/15/009-start-with-asset-bundle/"/>
    <id>https://snatix.com/2017/01/15/009-start-with-asset-bundle/</id>
    <published>2017-01-15T14:01:25.000Z</published>
    <updated>2020-01-16T01:51:21.822Z</updated>
    
    <content type="html"><![CDATA[<p>这理论上应该是一个冗长无比的系列，但是既然决定开这个深坑了就要好好填～其实一直以来都希望有一套自己熟悉的框架来自行维护，有什么想法的时候拿起来就能写，同时也有机会接触到 Unity 的方方面面而不是只会拼 UI 写业务系统。不管是 ulua 还是 slua，目的就是通过 AssetBundle 来更新，因此我们首先从 Assetbundle 开始。</p><a id="more"></a><h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>其实随便搜一搜就会发现关于 Unity5.x 的 Assetbundle 的文章超多，但是很多都是在结合 Unity4 的 Assetbundle 来对比着讲的，或者是讲的稍微有点深，某些很基础很的概念还没有普及到就开始使用了，看着很不爽。经过一小段时间的研究以后终于有了一些感觉，那么我来尝试用我自己的语言来向零基础的初次接触 Assetbundle 的同学们从头开始讲～</p><ol><li>什么是 Assetbundle，为什么要使用这个鬼东西</li><li>尝试随便写点代码用一下看看效果</li><li>据说可以自动处理依赖，试一试</li></ol><p>不知道为什么今天的文风比较随意，大家将就看吧~</p><h2 id="PART-2-Assetbundle-介绍"><a href="#PART-2-Assetbundle-介绍" class="headerlink" title="PART 2 Assetbundle 介绍"></a>PART 2 Assetbundle 介绍</h2><p>其实我很讨厌长篇大论的写东西来介绍某个概念，一是读起来太麻烦，二是我也写不出来。但是考虑到完整性，介绍一下又是不得不做的事情，我就不复制那些随便一搜一大堆的东西了，大概用自己的语言讲一下，讲的不对大家就当没看见就好了或者在评论区稍微提醒我修改～真想了解精准定义和概念的请移步「<a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html" target="_blank" rel="noopener">官方文档</a>」</p><h3 id="什么是-Assetbundle"><a href="#什么是-Assetbundle" class="headerlink" title="什么是 Assetbundle"></a>什么是 Assetbundle</h3><p>Asset 大家都知道是什么其实就是游戏用到的模型，贴图，场景，Prefab之类的资源。那么 Assetbundle 顾名思义就是把这些东西打成一个 Bundle。。。所以其实就是 Unity 官方提供了一种机制允许开发者把这些游戏资源打包放在自己的服务器，然后运行时再把 bundle 下载下来，把 Asset 解出来再使用。</p><h3 id="为什么要用-Assetbundle"><a href="#为什么要用-Assetbundle" class="headerlink" title="为什么要用 Assetbundle"></a>为什么要用 Assetbundle</h3><p>首先就是可以减少包体大小，有些公司的产品很在意这些因为某商店的安装包超过 100M 时就默认不允许玩家使用流量下载，因此可以把很大的模型场景贴图之类的移出去，然后玩家安装好游戏以后在游戏里继续下载直到全部资源都下载完毕才可以开始玩。</p><p>其次就是更新资源了，贴图模型和 Prefab 全都可以更新，用上 <a href="https://github.com/pangweiwei/slua" target="_blank" rel="noopener">slua</a> 或 <a href="https://github.com/topameng/tolua" target="_blank" rel="noopener">tolua</a> 的话连代码都可以更新，麻麻再也不怕我写出 bug 了~而且可以热更新的话就不需要每次修复 bug 或添加新特性都要更整包了有效提高玩家的用户体验。</p><p>大概的概念介绍到此结束，想了解更多的同学请自行翻阅「<a href="https://docs.unity3d.com/Manual/AssetBundlesIntro.html" target="_blank" rel="noopener">官方文档</a>」，俗话说 Talk is cheap, show me the code。所以我们接下来就用代码说话。</p><h2 id="PART-3-简单的尝试-Assetbundle"><a href="#PART-3-简单的尝试-Assetbundle" class="headerlink" title="PART 3 简单的尝试 Assetbundle"></a>PART 3 简单的尝试 Assetbundle</h2><p>首先做实验的第一步是生成 Assetbundle，那么新建工程新建场景脚本什么不说了直接观察目录结构</p><pre><code class="lang-tex">|---AssetManager    //Unity工程目录    |---Assets    //资源目录    |    |---AssetManager    //插件目录(博主最终想要把整个作成插件的形式)    |        |---Editor        //Editor脚本放置目录    |        |---Examples    //一大堆示例    |        |    |---Prefabs    |        |    |---Scenes    |        |    |---Textures    |        |    |        |---Scripts        //插件脚本    |        |---Bundls    //放置生成的AssetBundle的目录</code></pre><h3 id="写一句生成-Assetbundle-的代码"><a href="#写一句生成-Assetbundle-的代码" class="headerlink" title="写一句生成 Assetbundle 的代码"></a>写一句生成 Assetbundle 的代码</h3><p>那么如何生成 Assetbundle 呢？超级简单，核心就一个函数<code>BuildPipeline.BuildAssetBundles</code>。</p><pre><code class="lang-csharp">using UnityEditor;namespace AssetManager{    public class Menu    {        [MenuItem(&quot;AssetManager/Build AssetBundles&quot;)]        public static void BuildAssetBundles()        {            BuildPipeline.BuildAssetBundles(&quot;outputPath&quot;, BuildAssetBundleOptions.None, BuildTarget.StandaloneOSXUniversal);        }    }}</code></pre><p>在<code>AssetManager/Editor</code>下放置该文件就可以了。简单的说这样做可以让标题栏出现一个菜单<code>AssetManager/Build AssetBundles</code>，点一下就会自动生成 Assetbundle 了。是不是很方便，第一个参数是输出的路径，如我们项目结构的规划放置在与<code>Assets</code>同级的<code>Bundles</code>目录下，不出意外的话这个目录以后应该会反复用到，为了方便以后扩展最好做一个静态类 config 作为配置。</p><pre><code class="lang-csharp">using UnityEngine;namespace AssetManager{    public static class Config    {        public static string ABRootName = &quot;Bundles&quot;;        public static string ABOutputPath = Application.dataPath + &quot;/../&quot; + ABRootName;        public static string ABServerRootPath = &quot;http://192.168.31.40/&quot;;    }}</code></pre><p>这样就可以把第一段代码中的<code>&quot;outputPath&quot;</code>替换成<code>Config.ABOutputPath</code>了。那么生成的代码写完了，下一步就是做个 prefab 生成一下 Assetbundle 试试~</p><h3 id="随便制作一个-Prefab-做实验"><a href="#随便制作一个-Prefab-做实验" class="headerlink" title="随便制作一个 Prefab 做实验"></a>随便制作一个 Prefab 做实验</h3><p>制作 Prefab 的过程不多说了，大概就是随便放一张图在<code>Example/Textures</code>然后在做一个把一个带有 Sprite 的 GameObject 做成 Prefab，再把图片拖进去就行了，像是这样</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017012101.png" alt="制作一个Prefab"></p><p>为了等一下观察生成的 Assetbundle 的大小，我特意放了一张很大的图（博主的壁纸，在 Unity 中显示大小为 2.2M ）。最后把 Prefab 放在了<code>Example/Prefabs</code>文件夹，设置<code>Assetbundle Name</code>为<code>prefab_1</code>。这样这一步就完成了。</p><h3 id="生成一个-Assetbundle-并放在服务器上"><a href="#生成一个-Assetbundle-并放在服务器上" class="headerlink" title="生成一个 Assetbundle 并放在服务器上"></a>生成一个 Assetbundle 并放在服务器上</h3><p>第一步顺利完成的话，应该会看到菜单栏出现了名为<code>AssetManager</code>的菜单，点击<code>AssetManager/Build AssetBundles</code>，等待几秒钟就生成好了。</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017012102.png" alt="生成中"></p><p>生成好了以后应该可以在<code>Bundles</code>这个文件夹下看到四个文件，观察一下发现名为<code>prefab_1</code>的文件很大大约有1.4M，而<code>Bundles</code>这个文件却很小只有不到1K。为什么一个 Prefab 打成的 Assetbundle 会这么大呢？答案是这个 Bundle 里包含了 Prefab 依赖的全部资源，因此那张很大的壁纸也被包含在里面了。我们把两个不带<code>.manifest</code>后缀的文件上传到自己的 http 服务器上确保用浏览器可以访问到。</p><p>启动 Http 服务的方法很多，博主在局域网内另一台 Ubuntu 上某个文件夹直接运行以下命令：</p><pre><code class="lang-bash">$ sudo python -m SimpleHTTPServer 80</code></pre><p>就可以在当前文件夹下开启 Http 服务了，mac 想模拟的话大家自行寻找方法。上传文件也不说了博主就随便开启了个 ftp 就传了反正只是做实验。下一步是写一些代码把这个 Prefab 加载进来。</p><h3 id="加载-Assetbundle-中的-Prefab"><a href="#加载-Assetbundle-中的-Prefab" class="headerlink" title="加载 Assetbundle 中的 Prefab"></a>加载 Assetbundle 中的 Prefab</h3><p>新建一个场景<code>Example_1</code>，保存在<code>Example/Scenes</code>中，再新建一个 GameObject 名为<code>Example_1</code>，新建一个脚本名为<code>Example_1</code>，保存在<code>Example/Scripts</code>中，再挂在上一步创建好的 Prefab 上，开始写代码。</p><p>首先思路是使用<code>www</code>把这个文件下载下来，再把里面的内容 Load 进来，最后在场景中 Instanciate 这个 Prefab。实现这一套思路最简单的代码是这样的。</p><pre><code class="lang-csharp">using System.Collections;using UnityEngine;public class Example_1 : MonoBehaviour{    void Start()    {        StartCoroutine(LoadPrefabFromAssetBundle());    }    IEnumerator LoadPrefabFromAssetBundle()    {        WWW www = new WWW( Config.ABServerRootPath + &quot;prefab_1&quot;);        yield return www;        GameObject prefab = www.assetBundle.LoadAsset&lt;GameObject&gt;(&quot;prefab_1&quot;);        GameObject.Instantiate(prefab);    }}</code></pre><p>运行一下，等待几秒后成功的把该显示的加载出来了~（可能有10秒）图就不截了大家应该都想象得出来，就跟上面制作的一模一样。到此为止我们的 Assetbundle 最基础的用法已经掌握了。</p><h2 id="PART-4-自动依赖管理"><a href="#PART-4-自动依赖管理" class="headerlink" title="PART 4 自动依赖管理"></a>PART 4 自动依赖管理</h2><p>为什么会有依赖的问题呢？大家应该都发现了，把一个 Prefab 打成 Assetbundle 是会在生成的 Assetbundle 文件中包含所有依赖的资源，那么如果博主的壁纸在两个 Prefab 中使用呢？简单测试一下会发现生成的两个 Assetbundle 大小都约为1.4M。那么就会对玩家的流量造成极大的浪费，而且加载速度也会变慢。所以我们需要把他们依赖的公共资源单独打包至一个 Assetbundle 中。好的现在开始动手试试～</p><p>首先放一张新的图在<code>Examples/Textures</code>下随便放两张完全一样的贴图命名为<code>texture_2</code>和<code>texture_3</code>，然后设置<code>texture_2</code>的 AssetBundle Name 为<code>texrure_2</code>，<code>texture_3</code>不进行任何设置作为对照组，然后做两个 prefab 分别引用这张图片，再给 prefab 分别设置 AssetBundle Name 为 <code>prefab_2</code>和<code>prefab_3</code>。最后生成一下，好的具体步骤就不演示了~生成结果如下图所示</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017012601.png" alt="生成结果"></p><p>大家可以观察到生成的名为<code>prefab_2</code>的文件大小为 2KB ，小于<code>prefab_3</code>的 3KB，这充分表明他所依赖的资源已经被分离出去了因此打好的 Assetbundle 大小会变小。那么如果用之前加载 prefab 的方法把 prefab_2 加载出来会发生什么事情呢？简单的修改代码尝试一下会发现，结果如图所示</p><p><img src="https://blog-1301118239.cos.eu-frankfurt.myqcloud.com/Images/2017012602.png" alt="丢失Sprite"></p><p>我们的 Sprite 丢失了~那么正确的处理方式是怎样呢？答案是要先把他所依赖的 Assetbundle 加载好。那么如何获取依赖的 Assetbundle 呢？</p><pre><code class="lang-csharp">IEnumerator LoadDependenciesAndPrefab(){    WWW www = new WWW(Config.ABServerRootPath + Config.ABRootName);    yield return www;    AssetBundleManifest manifest = www.assetBundle.LoadAsset&lt;AssetBundleManifest&gt;(&quot;AssetBundleManifest&quot;);    string[] dependenceBundleName = manifest.GetAllDependencies(&quot;prefab_2&quot;);    foreach (string name in dependenceBundleName)    {        www = new WWW(Config.ABServerRootPath + name);        yield return www;        www.assetBundle.LoadAllAssets();      }      www = new WWW(Config.ABServerRootPath + &quot;prefab_2&quot;);      yield return www;     GameObject prefab = www.assetBundle.LoadAsset&lt;GameObject&gt;(&quot;prefab_2&quot;);    GameObject.Instantiate(prefab);}</code></pre><p>在<code>Start()</code>里开启一个协程调用以上函数试试～这应该是可以把一层依赖关系的 Assetbundle 解出来的最直观的代码了，不管好不好看至少可以非常清晰的理解思路。事实上不管多层依赖都只需要递归地把所有有依赖关系的 AssetBundle 用同样地方法解出来最后加载你想要的 Prefab 就可以了。</p><h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>这一篇写的非常基础也非常水，其实这也算是博主自己探索 Assetbundle 的过程的一个笔记～希望可以对像博主一样完全初次接触 Assetbundle 的同学有帮助。文章配套的工程已经放在博主的 <a href="https://github.com/sNaticY/unity-asset-manager" target="_blank" rel="noopener">github</a> 了。接下来就要随着学习的进行一步一步的构建我们的插件，希望最终可以实现配置好路径就可以完成自动设置 Assetbundle Name，生成和上传 Assetbundle，下载和加载资源等等操作而不需要过多的关注这些细节。不知道最终多久可以完成，希望不会太久远～加油！</p><hr><p>原文链接：<a href="https://snatix.com/2017/01/15/009-start-with-asset-bundle/">https://snatix.com/2017/01/15/009-start-with-asset-bundle/</a></p><p>本文由 <a href="https://github.com/sNaticY" target="_blank" rel="noopener">sNatic</a> 发布于『<a href="https://snatix.com">大喵的新窝</a>』 转载请保留本申明</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这理论上应该是一个冗长无比的系列，但是既然决定开这个深坑了就要好好填～其实一直以来都希望有一套自己熟悉的框架来自行维护，有什么想法的时候拿起来就能写，同时也有机会接触到 Unity 的方方面面而不是只会拼 UI 写业务系统。不管是 ulua 还是 slua，目的就是通过 AssetBundle 来更新，因此我们首先从 Assetbundle 开始。&lt;/p&gt;
    
    </summary>
    
      <category term="Unity通用框架工程" scheme="https://snatix.com/categories/Unity%E9%80%9A%E7%94%A8%E6%A1%86%E6%9E%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="unity" scheme="https://snatix.com/tags/unity/"/>
    
      <category term="asset bundle" scheme="https://snatix.com/tags/asset-bundle/"/>
    
  </entry>
  
</feed>
